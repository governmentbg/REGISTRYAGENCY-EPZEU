import { AsyncUIProps, BaseRouteParams, BaseRouteProps, BaseRoutePropsExt, withAsyncFrame, withRouter } from 'Cnsys.UI.React';
import { appConfig, Button, CMS, Country, EPZEUBaseComponent, IDataServiceProviderProps, Nomenclatures, PageTypes, Registers, ValidationSummaryErrors, withDataServiceProvider } from 'EPZEU.Core';
import { ApplicationFormTypes, Constants } from 'EPZEU.CR.Core';
import { ApplicationProviderFactory, Form, IApplicationProvider, ProcessStatuses } from 'EPZEU.CR.Domain';
import { action, observable, runInAction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { ApplicationProcessContext } from '../ApplicationProcessContext';
import { APApplicationProcess, APApplicationRequest } from '../Models/ModelsAutoGenerated';
import { AcceptedUI } from './AcceptedUI';
import { EditUI } from './EditUI';
import { ErrorUI } from './ErrorUI';
import { PreregistrationUI } from './PreregistrationUI';
import { SendingUI } from './SendingUI';
import { SignUI } from './SignUI';

interface LayoutUIRouteParams extends BaseRouteParams {
    applicationType: any
    applicationOrder: string
}

interface LayoutUIProps extends BaseRouteProps<LayoutUIRouteParams>, AsyncUIProps, BaseRoutePropsExt, IDataServiceProviderProps {
}

@observer class LayoutUIImpl extends EPZEUBaseComponent<LayoutUIProps, any> {
    forms: Form[];
    processContext: ApplicationProcessContext;
    provider: IApplicationProvider;
    startUI: any;
    bgCountry: Country;
    applicationType: ApplicationFormTypes;
    @observable reRender: boolean = false;
    @observable isContextLoading: boolean;

    constructor(props?: LayoutUIProps) {
        super(props);

        var applicationType: any = ApplicationFormTypes[this.props.match.params.applicationType]
        this.applicationType = applicationType;

        this.applicationProcessDeleted = this.applicationProcessDeleted.bind(this);
        this.appOrderChange = this.appOrderChange.bind(this);
        this.createApplicationProcess = this.createApplicationProcess.bind(this);
        this.startSigning = this.startSigning.bind(this);
        this.addAplication = this.addAplication.bind(this);
        this.startSending = this.startSending.bind(this);
        this.completePreregistration = this.completePreregistration.bind(this);
        this.signingCompleted = this.signingCompleted.bind(this);
        this.signingRejected = this.signingRejected.bind(this);
        this.deleteApplicationProcess = this.deleteApplicationProcess.bind(this);
        this.addChildApplicationProcess = this.addChildApplicationProcess.bind(this);
        this.returnToBeginningStatus = this.returnToBeginningStatus.bind(this);
        this.componentWillUnmount = this.componentWillUnmount.bind(this);
        this.returnToInitialPage = this.returnToInitialPage.bind(this);

        this.init();
    }

    render(): JSX.Element {
        var reRender = this.reRender;

        return (
            <>
                {
                    this.props.asyncErrorMessages && this.processContext && (!this.processContext.isContextInitialized || this.processContext.status != ProcessStatuses.InProcess) &&
                    <div className="general-message-wrapper">
                        <div className="section-wrapper">
                            <div className="fixed-content-width">
                                <ValidationSummaryErrors asyncErrors={this.props.asyncErrors} />
                            </div>
                        </div>
                    </div>
                }
                {
                    this.processContext.isContextInitialized && this.processContext.isPreregistration
                        ? (this.processContext.mainApplicationProcess.hasChangesInApplicationsNomenclature || this.processContext.mainApplicationProcess.hasChangeInApplicationsInitialData)
                            ? <div className="main-wrapper section-wrapper section-wrapper--margins fixed-content-width">
                                {this.renderApplicationCancelationUI()}
                            </div>
                            : <PreregistrationUI processContext={this.processContext} onApplicationProcessAdd={this.addChildApplicationProcess} onApplicationProcessDelete={this.deleteApplicationProcess} onCompletePreregistration={this.completePreregistration} />
                        : null
                }
                {
                    this.processContext.isContextInitialized && this.processContext.isPreregistration
                        && (this.processContext.mainApplicationProcess.hasChangesInApplicationsNomenclature || this.processContext.mainApplicationProcess.hasChangeInApplicationsInitialData)
                        ? null
                        : <div className="main-wrapper section-wrapper section-wrapper--margins fixed-content-width">
                            {!this.isContextLoading &&
                                this.renderApplicationUI()}
                        </div>
                }
            </>);
    }

    renderApplicationUI() {
        if (this.processContext.isContextInitialized && this.forms && this.forms.length > 0 &&
            (this.processContext.status == ProcessStatuses.InProcess ||
                this.processContext.status == ProcessStatuses.Signing ||
                this.processContext.status == ProcessStatuses.WaitPreregistrationCompletion)) {

            if (this.processContext.mainApplicationProcess.hasChangesInApplicationsNomenclature || this.processContext.mainApplicationProcess.hasChangeInApplicationsInitialData)
                return this.renderApplicationCancelationUI();

            switch (this.processContext.status) {
                case ProcessStatuses.InProcess:
                    return (
                        <EditUI
                            processContext={this.processContext}
                            applicationType={this.applicationType}
                            appOrder={this.props.match.params.applicationOrder}
                            anchor={this.props.location && this.props.location.hash ? this.props.location.hash.replace('#', '') : null}
                            onDeleteApplicationProcess={this.deleteApplicationProcess}
                            onAppOrderChange={this.appOrderChange}
                            onStartSigning={this.startSigning}
                            onStartSending={this.startSending}
                            errorMessages={this.props.asyncErrorMessages}
                            forms={this.forms}
                            onAddAplication={this.addAplication}
                        />);
                case ProcessStatuses.Signing:
                    return (
                        <SignUI
                            processContext={this.processContext}
                            onSingingCompleted={this.signingCompleted}
                            onSigningRejected={this.signingRejected}
                            forms={this.forms}
                            errorMessages={null}
                        />);
                case ProcessStatuses.WaitPreregistrationCompletion: {
                    if (this.processContext.currentApplicationProcess.status == ProcessStatuses.InProcess) {
                        return (
                            <EditUI
                                processContext={this.processContext}
                                applicationType={this.applicationType}
                                appOrder={this.props.match.params.applicationOrder}
                                anchor={this.props.location && this.props.location.hash ? this.props.location.hash.replace('#', '') : null}
                                onDeleteApplicationProcess={this.deleteApplicationProcess}
                                onAppOrderChange={this.appOrderChange}
                                onStartSigning={this.startSigning}
                                onStartSending={this.startSending}
                                errorMessages={this.props.asyncErrorMessages}
                                forms={this.forms}
                                onAddAplication={this.addAplication}
                            />);
                    }
                    if (this.processContext.currentApplicationProcess.status == ProcessStatuses.Signing) {
                        return (
                            <SignUI
                                processContext={this.processContext}
                                onSingingCompleted={this.signingCompleted}
                                onSigningRejected={this.signingRejected}
                                forms={this.forms}
                                errorMessages={null}
                            />);
                    }
                }
            }
        }
        else if (this.processContext.isContextInitialized) {
            switch (this.processContext.status) {
                case ProcessStatuses.ErrorInSignature:
                case ProcessStatuses.ErrorInAccepting:
                    return (
                        <ErrorUI processContext={this.processContext} errorMessages={this.props.asyncErrorMessages} onDeleteApplicationProcess={this.deleteApplicationProcess} onReturnToBeginningStatus={this.returnToBeginningStatus} />
                    );
                case ProcessStatuses.ReadyForSending:
                case ProcessStatuses.Sending:
                case ProcessStatuses.Accepted: {
                    return <SendingUI processStatus={this.processContext.status} />
                }
                case ProcessStatuses.Completed: {
                    return (
                        <AcceptedUI processContext={this.processContext} errorMessages={this.props.asyncErrorMessages} onDeleteApplicationProcess={this.deleteApplicationProcess} />);
                }
                case ProcessStatuses.WaitPreregistrationCompletion: {
                    return null;
                }
            }
        }
        else {
            return (this.startUI &&
                <this.startUI
                    createApplicationProcess={this.createApplicationProcess}
                    applicationType={this.applicationType}
                    errorMessages={null}
                    returnToInitialPage={this.returnToInitialPage}
                />);

        }
    }

    renderApplicationCancelationUI() {
        let currentApplicationProcess = this.processContext.currentApplicationProcess ? this.processContext.currentApplicationProcess : this.processContext.mainApplicationProcess;

        return <div className="page-wrapper">
            <div className="section-wrapper">
                <div className="row">
                    <div className="form-group col">
                        <div className="alert alert-danger">
                            {
                                this.processContext.mainApplicationProcess.hasChangesInApplicationsNomenclature
                                    ? this.getResource(this.getErrorKeyForChangesInApplicationsNomenclature(currentApplicationProcess.mainApplicationType))
                                    : this.getResource("CR_APP_CHANGED_BATCH_FOR_APP_I")
                            }
                        </div>
                    </div>
                </div>
                <div className="button-bar button-bar--form">
                    <div className="left-side">
                        {
                            this.processContext.isPreregistration ?
                                <Button type="button" className="btn btn-secondary" lableTextKey={"CR_APP_REFUSE_REREGISTRATION_L"} onClick={this.deleteApplicationProcess}></Button> :
                                <Button type="button" className="btn btn-secondary" lableTextKey={"GL_REFUSE_L"} onClick={() => this.deleteApplicationProcess(currentApplicationProcess)}></Button>
                        }
                    </div>
                    <div className="right-side">
                    </div>
                </div>
            </div>
        </div>
    }

    //#region Event

    componentWillUpdate(nextProps: LayoutUIProps, nextState: any, nextContext: any): void {
        super.componentWillUpdate(nextProps, nextState, nextContext);

        if (this.props.match.params.applicationType != nextProps.match.params.applicationType) {
            var applicationType: any = ApplicationFormTypes[nextProps.match.params.applicationType]
            this.applicationType = applicationType;

            this.init();
        }
    }

    componentWillUnmount(): void {
        if (super.componentWillUnmount) {
            super.componentWillUnmount();
        }

        this.processContext.clearContext();
    }

    startSigning() {
        this.props.registerAsyncOperation(this.processContext.startSinging().bind(this).then(() => {
            this.props.routerExt.goTo(this.getApplicationProcessURL(), null);
        }));
    }

    appOrderChange(appOrder: string, anchor?: string, isChangedApp?: boolean) {
        if (anchor) {
            if (this.props.location.hash && !isChangedApp && this.props.location.hash.replace('#', '') == anchor)
                document.getElementById(anchor).scrollIntoView(); //Ако сме преместили скрола по-надолу, при повторно натискане на текущата секция, ни фокусира отново на нея.
            else
                this.props.routerExt.goTo(this.getApplicationProcessURL(appOrder, anchor), null);
        } else
            this.props.routerExt.goTo(this.getApplicationProcessURL(appOrder), null);
    }

    createApplicationProcess(request: { applicationType: ApplicationFormTypes, additionalData: any }): Promise<void> {
        var procRequest = new APApplicationRequest();

        procRequest.applicationType = request.applicationType;
        procRequest.additionalData = request.additionalData;

        return this.processContext.createApplicationProcess(procRequest).bind(this).then(() => {
            this.initForms();
            this.reRender = !this.reRender;
        });
    }

    addAplication(request: APApplicationRequest): Promise<Form> {
        return this.processContext.addApplication(request).bind(this).then(appItem => {

            var form = appItem.applicationProvider.getApplicationForms(appItem, this.props.dataSrvProvider)[0];

            this.forms.push(form);

            this.forms = this.forms.sort((item1, item2) => Number(item1.order) > Number(item2.order) ? 1 : -1);

            return form;
        })
    }

    signingCompleted(): Promise<void> {
        this.isContextLoading = true;

        return this.processContext.signingCompleted().bind(this).then(() => {
            this.initForms();
            this.isContextLoading = false;
            window.scrollTo(0, 0);
        });
    }

    @action signingRejected(): Promise<void> {
        this.processContext.signingRejected();
        this.reRender = !this.reRender;
        window.scrollTo(0, 0);

        return Promise.resolve();
    }

    returnToBeginningStatus() {
        this.props.registerAsyncOperation(this.processContext.returnToBeginningStatus().bind(this).then(() => {
            this.reRender = !this.reRender;
        }))
    }

    startSending() {
        this.props.registerAsyncOperation(this.processContext.startSending().bind(this).then(() => {
            this.reRender = !this.reRender;
        }))
    }

    completePreregistration() {
        this.isContextLoading = true;

        this.props.registerAsyncOperation(this.processContext.completePreregistration().bind(this).then(() => {
            this.isContextLoading = false;
        }))
    }

    deleteApplicationProcess(appProcess?: APApplicationProcess | any) {
        if (appProcess && appProcess.parentApplicationProcessID) {
            this.props.registerAsyncOperation(this.processContext.deleteChildApplicationProcess(appProcess).bind(this).then(() => {
                return this.applicationProcessDeleted();
            }));
        }
        else {
            this.props.registerAsyncOperation((this.processContext.deleteApplicationProcess().bind(this).then(() => {
                return this.applicationProcessDeleted();
            })));
        }
    }

    addChildApplicationProcess(request: APApplicationRequest): Promise<void> {
        this.isContextLoading = true;
        return this.processContext.addChildApplicationProcess(request).bind(this).then(() => {
            runInAction(() => {
                this.initForms();
                this.isContextLoading = false;
            });
        });
    }

    //#endregion

    //#region Helpers

    @action init() {
        this.isContextLoading = true;
        this.processContext = new ApplicationProcessContext();

        var tryLoadPromise = this.processContext.tryLoadApplicationProcess(this.applicationType);
        var providerPromise = ApplicationProviderFactory.getApplicationProvider(this.applicationType);
        var bgCountryPromise = Nomenclatures.getBGCountry();

        this.props.registerAsyncOperation(Promise.all([tryLoadPromise, providerPromise, bgCountryPromise]).bind(this).then(result => {
            this.provider = result[1];
            this.bgCountry = result[2];
            this.startUI = this.provider.getStartUIComponentType();

            if (result[0]) {
                this.initForms();
                this.isContextLoading = false;

                return Promise.resolve();
            }
            else {
                return this.initAutomaticallyApplication().bind(this).then(() => {
                    this.isContextLoading = false;
                })
            }
        }), true);
    }

    initAutomaticallyApplication(): Promise<void> {
        if (!this.provider.getStartUIComponentType()) {
            var request = new APApplicationRequest();
            request.applicationType = this.applicationType;

            return this.processContext.createApplicationProcess(request).bind(this).then(() => {
                this.initForms();
            });
        }

        return Promise.resolve();
    }

    initForms(): void {
        this.forms = [];

        for (var appItem of this.processContext.applicationItems) {
            this.forms.push(...appItem.applicationProvider.getApplicationForms(appItem, this.props.dataSrvProvider));
        }

        this.forms = this.forms.sort((item1, item2) => Number(item1.order) > Number(item2.order) ? 1 : -1);
    }

    getApplicationProcessURL(appOrder?: string, anchor?: string): string {

        let currenntUrl: string = this.props.location.pathname.replace(appConfig.baseUrlName, "");

        //Пътят прреди applicationProcesses може да е от услуги или от заявления и искаме да се запази за да се знае от къде сме дошли.
        let applProcIndex = currenntUrl.lastIndexOf(appConfig.paths.applicationProcesses);
        let url = currenntUrl.substr(0, applProcIndex);

        url = url + Constants.PATHS.APPLICATION_PROCESSES_SIMPLE;
        url = url.replace(":applicationType", ApplicationFormTypes[this.applicationType]).replace("//", "/");

        if (appOrder) {
            url = url.replace(":applicationOrder?", appOrder);
        }
        else {
            url = url.replace("/:applicationOrder?", "");
        }

        if (anchor) {
            url = url + `#${anchor}`
        }

        return url;
    }

    getErrorKeyForChangesInApplicationsNomenclature(appType: ApplicationFormTypes) {
        switch (appType) {
            case ApplicationFormTypes.AppointingExpert:
            case ApplicationFormTypes.AppointingDeclaration:
            case ApplicationFormTypes.AppointingReportAndExamination:
            case ApplicationFormTypes.AppointingRequestForCorrection:
            case ApplicationFormTypes.AppointingControllerReward:
            case ApplicationFormTypes.AppointingReleaseDeposit:
            case ApplicationFormTypes.AppointingChangeRequest:
            case ApplicationFormTypes.ReleaseAppointingExpert:
            case ApplicationFormTypes.AppointingPaidDeposit:
            case ApplicationFormTypes.AttitudeOfChangeRequest:
            case ApplicationFormTypes.NotificationOfLackOfMeans:
            case ApplicationFormTypes.AppointingContactAddressChange:
            case ApplicationFormTypes.NotificationOfExaminationImpossibility:
            case ApplicationFormTypes.RequestForCorrection:
            case ApplicationFormTypes.ActOfContestation:
            case ApplicationFormTypes.Complaint:
                return 'CR_APP_CHANGED_NOMENCLATURES_FOR_REQ_I';
        }

        return 'CR_APP_CHANGED_NOMENCLATURES_I';
    }

    applicationProcessDeleted(): Promise<void> {
        if (this.provider.getStartUIComponentType()) {
            if (this.processContext.isContextInitialized) {
                this.initForms();
                this.reRender = !this.reRender;
            }
            else {
                this.forms = [];

                this.props.registerAsyncOperation(
                    this.initAutomaticallyApplication().then(() => {
                        this.reRender = !this.reRender;
                    })
                )
                this.props.routerExt.goTo(this.getApplicationProcessURL(), null);
            }

            return Promise.resolve();
        }
        else {
            return this.returnToInitialPage();
        }
    }

    returnToInitialPage(): Promise<void> {
        let redirectUrl = appConfig.paths.applications;

        return Nomenclatures.getServices(srv => srv.applicationType && srv.applicationType.appType == this.applicationType.toString()).bind(this).then(services => {

            if (services && services.length == 1) {
                return CMS.getPages(pg =>
                    pg.registerID == Registers.CR
                    && pg.type == PageTypes.Service
                    && pg.serviceID == services[0].serviceID).bind(this).then(pages => {
                        if (pages != null && pages != undefined && pages.length >= 1) {
                            redirectUrl = appConfig.paths.service.replace(':serviceID', services[0].serviceID.toString())
                        }

                        this.props.routerExt.goTo(redirectUrl, null);
                    })
            }
            else {
                this.props.routerExt.goTo(redirectUrl, null);
            }
        });
    }

    //#endregion
}

export const ApplicationProcessLayoutUI = withAsyncFrame(withRouter(withDataServiceProvider(LayoutUIImpl)), false); 