import { ErrorHelper, ErrorInfo, ErrorLevels, ObjectHelper } from 'Cnsys.Core';
import { AsyncUIProps, BaseProps, ConfirmationModal, ViewMode, withAsyncFrame } from 'Cnsys.UI.React';
import { appConfig, Button, EPZEUBaseComponent, MobileMenuToggle, StickyBottomElementForIE, ValidationSummaryErrors } from 'EPZEU.Core';
import { ApplicationFormTypes } from 'EPZEU.CR.Core';
import { applicantExchangeOrderNumber, applicantInfoOrderNumber, ApplicationFormContextProviderUI, entityIdentificationOrderNumber, Form, FormState, gDPRAgreementOrderNumber, isApplicationWithFieldsFormManager, MenuNavItem } from 'EPZEU.CR.Domain';
import { action, extendObservable, observable, runInAction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { ApplicationProcessContext } from '../ApplicationProcessContext';
import { APApplicationProcess, APApplicationRequest } from '../Models/ModelsAutoGenerated';
import { MenuUI } from './MenuUI';
import { PreviewUI } from './PreviewUI';

interface EditUIProps extends BaseProps, AsyncUIProps {
    processContext: ApplicationProcessContext;
    applicationType: any;
    appOrder?: string;
    anchor?: string;
    onDeleteApplicationProcess: (appProcess: APApplicationProcess) => void;
    onAppOrderChange: (appOrder: string, anchor?: string, isChangedApp?: boolean) => void;
    onStartSigning: () => void;
    onStartSending: () => void;
    errorMessages: any;
    forms: Form[];
    onAddAplication: (request: APApplicationRequest) => Promise<Form>
}

var rejectApplication = ['GL_REJECT_MSG_00001_L', 'GL_REJECT_MSG_00002_L'];
var rejectGroupOfApplications = ['GL_REJECT_MSG_00003_L', 'GL_REJECT_MSG_00004_L'];

@observer class EditUIImpl extends EPZEUBaseComponent<EditUIProps, any> {
    @observable currentForm: Form;
    @observable reRenderMenu: boolean;

    private lastSavedApplication: any = undefined;
    private isAutosaveUpdate: boolean = false;
    private saveAppTimeout: number;

    constructor(props?: EditUIProps) {
        super(props);

        //Подаваме контекст на методите             
        this.onApplicationChange = this.onApplicationChange.bind(this);
        this.onDeleteApplication = this.onDeleteApplication.bind(this);
        this.onNextApplication = this.onNextApplication.bind(this);
        this.onPreview = this.onPreview.bind(this);
        this.onStartSigning = this.onStartSigning.bind(this);
        this.startSending = this.startSending.bind(this);
        this.componentDidUpdate = this.componentDidUpdate.bind(this);
        this.onAddAplication = this.onAddAplication.bind(this);
        this.saveApplicationPeriodically = this.saveApplicationPeriodically.bind(this);

        if (this.props.appOrder && this.props.appOrder == "preview") {
            this.validateAllForms();
        }
        else if (this.props.appOrder && this.props.forms.filter(f => f.order == this.props.appOrder).length > 0) {
            this.currentForm = this.props.forms.filter(f => f.order == this.props.appOrder)[0];
        }
        else {
            this.currentForm = this.props.forms[0];
        }
    }

    render(): JSX.Element {
        return (
            <>
                <div className="button-menu-container">
                    <MobileMenuToggle />
                </div>
                <MenuUI reRender={this.reRenderMenu} applicationItems={this.props.processContext.applicationItems} items={this.props.forms} onApplicationChange={this.onApplicationChange} onApplicationDelete={this.onDeleteApplication} getPossibleAdditionalApplicationFormTypes={this.props.processContext.getAdditionalApplicationFormTypes} onApplicationAdd={this.onAddAplication} />
                <div className="page-wrapper" id="appTop">
                    <div className="section-wrapper">
                        <ValidationSummaryErrors errors={this.props.asyncErrorMessages} />
                        <ValidationSummaryErrors errors={this.props.errorMessages} />
                        {this.currentForm ?
                            this.renderEdit() :
                            <PreviewUI forms={this.props.forms} onEditApplication={(form: Form) => { this.onApplicationChange(form.order) }} onDeleteApplication={this.onDeleteApplication} />
                        }
                        {this.renderButtons()}
                    </div>
                </div>
            </>
        );
    }

    renderEdit(): JSX.Element {
        var appProps = this.bind(this.currentForm.form, ViewMode.Edit, "application", [this.currentForm.formValidator]);

        return (
            <>
                <ApplicationFormContextProviderUI applicationManager={this.currentForm.formManager}>
                    {React.createElement(this.currentForm.formUICmp, appProps)}
                </ApplicationFormContextProviderUI>
            </>
        );
    }

    renderButtons(): JSX.Element {
        let that = this;
        return (<StickyBottomElementForIE stickyElementId="sticky-bottom-bar" outerElementId="appTop">
            <div id="sticky-bottom-bar" className="button-bar button-bar--form button-bar--sticky">
                <div className="left-side">
                    {!this.props.processContext.isPreregistration &&
                        <ConfirmationModal modalTitleKey='GL_REJECT_ALL_APPLICATIONS_L' modalTextKeys={rejectGroupOfApplications} onSuccess={this.onDeleteApplicationProcess.bind(this, this.props.processContext.mainApplicationProcess)} yesTextKey='GL_DECLINE_GROUP_APPLICATIONS_L' noTextKey='GL_BACK_TO_APPLICATION_L'>
                            <Button type="button" className="btn btn-secondary" lableTextKey={"GL_REFUSE_L"}></Button>
                        </ConfirmationModal>}
                    {this.props.processContext.isPreregistration &&
                        <ConfirmationModal modalTitleKey='GL_REJECT_ALL_APPLICATIONS_L' modalTextKeys={rejectGroupOfApplications} onSuccess={this.onDeleteApplicationProcess.bind(this, this.props.processContext.mainApplicationProcess)} yesTextKey='GL_DECLINE_GROUP_APPLICATIONS_L' noTextKey='GL_BACK_TO_APPLICATION_L'>
                            <Button type="button" className="btn btn-secondary" lableTextKey={"CR_APP_REFUSE_REREGISTRATION_L"}></Button>
                        </ConfirmationModal>}
                    {this.props.processContext.isPreregistration && this.props.processContext.currentApplicationProcess != this.props.processContext.mainApplicationProcess &&
                        <ConfirmationModal modalTitleKey='GL_REJECT_APPLICATION_L' modalTextKeys={rejectApplication} onSuccess={this.onDeleteApplicationProcess.bind(this, this.props.processContext.currentApplicationProcess)} yesTextKey='GL_DECLINE_APPLICATION_L' noTextKey='GL_BACK_TO_APPLICATION_L'>
                            <Button type="button" className="btn btn-secondary" lableTextKey={"GL_APPLICATION_REJECT_L"}></Button>
                        </ConfirmationModal>}
                    {
                        this.currentForm && this.currentForm.canDelete &&
                        <ConfirmationModal modalTitleKey='GL_REJECT_APPLICATION_L' modalTextKeys={rejectApplication} onSuccess={() => this.onDeleteApplication(this.currentForm)} yesTextKey='GL_DECLINE_APPLICATION_L' noTextKey='GL_BACK_TO_APPLICATION_L'>
                            <Button type="button" className="btn btn-secondary" lableTextKey={"GL_APPLICATION_REJECT_L"} ></Button>
                        </ConfirmationModal>

                    }
                </div>
                <div className="right-side">
                    {
                        this.currentForm &&
                        <Button type="button" className="btn btn-secondary" lableTextKey={"GL_ACTION_VIEW_L"} onClick={this.onPreview}></Button>
                    }
                    {
                        this.currentForm &&
                        <Button type="button" className="btn btn-primary" lableTextKey={'GL_CONTINUE_L'} onClick={this.onNextApplication}></Button>
                    }
                    {
                        !this.currentForm && this.canContinueSending() ?
                            this.isApplicationWithoutSigning(this.props.processContext.applicationItems.filter(app => app.isMainAppl)[0].applicationManager.application.appType) ?
                                <Button type="button" className="btn btn-primary" lableTextKey={'GL_SUBMIT_L'} onClick={this.startSending}></Button> :
                                <Button type="button" className="btn btn-primary" lableTextKey={'GL_SIGN_L'} onClick={this.onStartSigning}></Button>
                            : null
                    }
                </div>
            </div></StickyBottomElementForIE>);
    }

    //#region Edit Events

    onDeleteApplication(form: Form): void {
        this.props.registerAsyncOperation(this.props.processContext.deleteApplication(form.formManager.application).bind(this).then(() => {
            var formIndex = this.props.forms.indexOf(this.props.forms.filter(f => f.order == form.order)[0]);
            if (formIndex > -1) { this.props.forms.splice(formIndex, 1) } else { null };

            if (this.currentForm && (form.order == this.currentForm.order))
                this.props.onAppOrderChange(this.props.forms.filter(app => app.isMain)[0].order);

            if (this.props.appOrder == "preview") {
                this.validateAllForms();
            }
            else {
                runInAction(() => {


                    //При изтриване на допълнително заявление трябва промяната да се отрази в менюто и в content-a.
                    this.reRenderMenu = !this.reRenderMenu;
                    this.forceUpdate();
                })
            }
        }))
    }

    onAddAplication(request: APApplicationRequest): Promise<void> {
        return this.props.onAddAplication(request).bind(this).then(form => {
            this.currentForm = form;
        });
    }

    onDeleteApplicationProcess(appProcess: APApplicationProcess): void {
        this.props.onDeleteApplicationProcess(appProcess);
    }

    onPreview(): void {
        this.onApplicationChange("preview")
    }

    onNextApplication(): void {
        var currentFormIndex = this.props.forms.indexOf(this.props.forms.filter(f => f.order == this.currentForm.order)[0]);

        if (currentFormIndex == this.props.forms.length - 1) {
            this.onApplicationChange("preview");
        }
        else {
            this.onApplicationChange(this.props.forms[currentFormIndex + 1].order);
        }
    }

    onStartSigning(): void {
        this.props.onStartSigning();
    }

    startSending(): void {
        this.props.onStartSending();
    }

    //#endregion

    //#region Menu Events

    @action private onApplicationChange(formKey: any, anchor?: string): void {
        var doAppChange = false;

        let nextOrder = this.props.appOrder;

        if (this.currentForm) {
            var currentForm = this.props.forms.filter(f => f.order == this.currentForm.order)[0];

            if (currentForm.formManager && isApplicationWithFieldsFormManager(currentForm.formManager) &&
                currentForm.order != entityIdentificationOrderNumber && currentForm.order != applicantExchangeOrderNumber && currentForm.order != applicantInfoOrderNumber && currentForm.order != gDPRAgreementOrderNumber) {
                currentForm.formManager.updateRecordsOperation();
            }

            var currentFormErrors = currentForm.errors;

            if (nextOrder != 'preview') {
                var valResult = this.validateForm(currentForm)

                this.reRenderMenu = !this.reRenderMenu;

                if (!valResult) {
                    if (this.compareErrors(currentForm.errors, currentFormErrors))
                        doAppChange = true;

                } else
                    doAppChange = valResult;

                currentForm.state = valResult ? FormState.Completed : FormState.WithError;

                if (doAppChange) {
                    if (this.currentForm) {
                        this.props.processContext.saveApplication(this.currentForm.formManager.application);
                        this.lastSavedApplication = JSON.stringify(this.currentForm.formManager.application);
                    }

                    if (anchor)
                        this.props.onAppOrderChange(formKey, anchor, nextOrder != formKey);
                    else
                        this.props.onAppOrderChange(formKey);
                }
            }
        }
        else {
            if (anchor)
                this.props.onAppOrderChange(formKey, anchor, nextOrder != formKey);
            else
                this.props.onAppOrderChange(formKey);
        }
    }

    //#endregion

    //#region Helpers

    saveApplicationPeriodically() {
        let that = this;

        //Стартираме периодичното записване на черновата.
        that.saveAppTimeout = setTimeout(() => {

            that.saveApplicationPeriodically();

            if (that.currentForm) {
                let currentApplication = JSON.stringify(that.currentForm.formManager.application);

                if (currentApplication != that.lastSavedApplication) {
                    that.isAutosaveUpdate = true;

                    that.props.processContext.saveApplication(that.currentForm.formManager.application).then(() => {
                        that.lastSavedApplication = currentApplication;
                    });
                }
            }

        }, appConfig.appSaveIntervalInMs);
    }

    componentDidMount() {
        this.saveApplicationPeriodically();

        let nextOrder = this.props.appOrder;

        if (!ObjectHelper.isNullOrUndefined(this.props.forms)) {

            if (ObjectHelper.isNullOrUndefined(nextOrder) && this.props.forms.length > 0)
                this.defineCurrenMenuItem(this.props.forms[0], this.props);
            else {
                let nextForm = this.props.forms.filter(item => item.order == nextOrder)[0];

                if (nextOrder != 'preview')
                    this.defineCurrenMenuItem(nextForm, this.props);
            }
        }
    }

    componentWillUnmount() {
        //Зачистваме периодичното записване на черновата.
        clearTimeout(this.saveAppTimeout);
    }

    @action componentWillUpdate(nextProps: EditUIProps, nextState: any, nextContext: any): void {
        super.componentWillUpdate(nextProps, nextState, nextContext);

        var nextOrder = nextProps.appOrder;
        var nextForm = this.props.forms.filter(item => item.order == nextOrder)[0];

        //Зачистваме, ако е сетнато "isCurrent" на някой от елеменентите в менюто
        for (var i = 0; i < this.props.forms.length; i++) {
            for (var j = 0; j < this.props.forms[i].formMenuNavItems.length; j++) {
                this.setMenuItemIsSelected(this.props.forms[i].formMenuNavItems[j], false);
            }
        }

        if (ObjectHelper.isNullOrUndefined(nextOrder) && nextProps.forms.length > 0)
            this.defineCurrenMenuItem(nextProps.forms[0], nextProps);
        else {
            let nextForm = this.props.forms.filter(item => item.order == nextOrder)[0];

            if (nextOrder != 'preview')
                this.defineCurrenMenuItem(nextForm, nextProps);
        }

        if (nextOrder &&
            ((this.currentForm && nextOrder != this.currentForm.order) ||
                (!this.currentForm && nextOrder != 'preview'))) {

            if (nextOrder == 'preview') {
                this.validateAllForms();
                this.currentForm = null;
            }
            else
                this.currentForm = nextForm;
        }
    }

    componentDidUpdate(prevProps: EditUIProps, prevState: any): void {

        if (this.isAutosaveUpdate) {
            this.isAutosaveUpdate = false;
        } else {
            var elemToNav = $('#appTop');
            if (this.props.anchor) {
                elemToNav = $('#' + this.props.anchor);
            }

            if (elemToNav && elemToNav.length > 0) {
                //TRIR-3670 При определени заявления не се препраща в началото. Получава се разминаване.
                setTimeout(() => {
                    elemToNav[0].scrollIntoView();
                }, 100)
            }
        }
    }

    @action private defineCurrenMenuItem(currentForm: Form, props: EditUIProps) {
        if (currentForm) {
            for (var i = 0; i < currentForm.formMenuNavItems.length; i++) {
                if (!currentForm.formMenuNavItems[i].isApplicationTitle) {
                    if (currentForm.formMenuNavItems[i].anchor) {
                        if (currentForm.formMenuNavItems[i].anchor == props.anchor)
                            this.setMenuItemIsSelected(currentForm.formMenuNavItems[i], true);

                    } else
                        this.setMenuItemIsSelected(currentForm.formMenuNavItems[i], true);
                }
            }
        } else {
            //Сетваме "Данни за заявител дефолтно на активно, ако нямаме избрано друго от менюто."
            if (props.forms) {
                for (var i = 0; i < props.forms.length; i++) {
                    if (props.forms[i].order == '1') {
                        this.setMenuItemIsSelected(props.forms[i].formMenuNavItems[0], true);
                        break;
                    }
                }
            }

        }
    }

    private compareErrors(errs1: ErrorInfo[], errs2: ErrorInfo[]): boolean {
        if ((!errs1 || errs1.length == 0) &&
            (!errs2 || errs2.length == 0)) {
            return true;
        }

        if (!errs1 || errs1.length == 0) {
            return false;
        }

        if (!errs2 || errs2.length == 0) {
            return false;
        }

        if (errs1.length != errs2.length) {
            return false;
        }

        for (var i = 0; i < errs1.length; i++) {
            if (errs1[i].error != errs2[i].error || errs1[i].propertyName != errs2[i].propertyName) {
                return false;
            }
        }

        return true;
    }

    @action private async validateAllForms() {
        for (var form of this.props.forms) {
            form.state = this.validateForm(form) ? FormState.Completed : FormState.WithError;
        }

        this.reRenderMenu = !this.reRenderMenu;
    }

    @action private validateForm(form: Form): boolean {
        var isValid = form.formValidator.validate(form.form);
        form.errors = [];

        if (!isValid) {
            form.errors = ErrorHelper.getErrorsRecursive(form.form);

            if (form.isMain && this.props.forms.length > 1) {
                form.errors = form.errors.filter(err => err.propertyName.indexOf("applicantExchange") != 0 && err.propertyName.indexOf("uic") != 0 && err.propertyName.indexOf("isGDPRAgreementAccepted") != 0);
            }

            if (form.errorPropNames && form.errorPropNames.length > 0) {
                let err = [];

                for (var i = 0; i < form.errorPropNames.length; i++) {
                    err.push(...form.errors.filter(error => error.propertyName.indexOf(form.errorPropNames[i]) > -1));
                }

                form.errors = err

                if (form.errors.length == 0)
                    return true;
            }
        }

        return isValid;
    }

    ///Правим полето isCurrent за да може да тригрне прерисуване на менюто при промяна на стойноста му
    private setMenuItemIsSelected(item: MenuNavItem, value: boolean) {
        if (item.isCurrent == undefined) {
            extendObservable(item, {
                isCurrent: value
            })
        }//добавена е проверка дали е различно, заради mobx.
        else if (item.isCurrent != value) {
            item.isCurrent = value;
        }
    }

    canContinueSending(): boolean {
        var result = true;

        for (var form of this.props.forms) {
            if (form.errors) {
                for (var err of form.errors) {
                    if (err.level == ErrorLevels.Error) {
                        result = false;
                        break;
                    }
                }

                if (!result) {
                    break;
                }
            }
        }

        return result;
    }

    isApplicationWithoutSigning(appType: ApplicationFormTypes): boolean {

        switch (appType) {
            case ApplicationFormTypes.CertificateForReserveFirm:
            case ApplicationFormTypes.ActOrCopyOfActCertificate:
            case ApplicationFormTypes.EnteredCircumstancesCertificate:
            case ApplicationFormTypes.MissingActsCertificate:
            case ApplicationFormTypes.PublicationByPeriodCertificate:
            case ApplicationFormTypes.EntryByPeriodCertificate:
            case ApplicationFormTypes.ActualStateCertificate:
                return true;
        }

        return false;
    }

    //#endregion
}

export const EditUI = withAsyncFrame(EditUIImpl, false);