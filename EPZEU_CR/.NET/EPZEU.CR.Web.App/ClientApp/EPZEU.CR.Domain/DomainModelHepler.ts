import { BaseDataModel, ObjectHelper, TypeSystem } from 'Cnsys.Core';
import { isMoment } from 'moment';
import { Dictionary } from 'typescript-collections';
import { ApplicationFormFieldsBase, ApplicationWithFieldsFormBase, CompositeField, IndentTypes, Record, RecordField, RecordOperations } from './Models/ModelsAutoGenerated';
import { ValidatorHelpers } from './Models/Validators';
import { IndentValidationMode } from './UI';

export namespace DomainModelHepler {

    function getRecordSystemProps(): string[] {
        var recordSystemProps: string[] = [];

        var recObj = JSON.parse(JSON.stringify(new RecordField()))
        for (var prop in recObj) {
            recordSystemProps.push(prop);
        }

        return recordSystemProps;
    }

    var recordSystemProps = getRecordSystemProps();

    export function isFieldEmpty(field: RecordField | CompositeField): boolean {
        return isObjectEmpty(field);
    }

    export function isRecordEmpty(obj: Record, propsDefaultValues: Dictionary<string, any> = undefined): boolean {
        return isObjectEmpty(obj, propsDefaultValues);
    }

    export function isRecordNew(obj: Record): boolean {
        if (obj.recordID && Number(obj.recordID)) {
            return false;
        }
        else {
            return true;
        }
    }

    export function isRecordDirty(record: Record): boolean {
        if (record.initialState) {
            return compareWithModelInitState(record, record.initialState)
        }//Записа е добавен в javascrip-та
        else {
            return !isRecordEmpty(record);
        }
    }

    export function isRecord(obj: Record | any): obj is Record {
        return ObjectHelper.isSubClassOf(obj, Record);
    }

    export function isRecordField(obj: RecordField | any): obj is RecordField {
        return ObjectHelper.isSubClassOf(obj, RecordField);
    }

    export function isCompositeField(obj: CompositeField | any): obj is CompositeField {
        return ObjectHelper.isSubClassOf(obj, CompositeField);
    }

    export function getAllRecords(application: ApplicationWithFieldsFormBase<ApplicationFormFieldsBase>): Record[] {
        return getAllRecordsFromFieldsBase(application.fields);
    }

    export function getAllRecordsFromFieldsBase(fieldsBase: ApplicationFormFieldsBase): Record[] {
        var records = [];

        for (var prop in fieldsBase) {
            if (prop == "errors" || prop == "constructor" || prop.indexOf("_") != 0) {
                continue;
            }

            if (isRecordField((fieldsBase as any)[prop])) {
                records.push((fieldsBase as any)[prop])
            }

            if (isCompositeField((fieldsBase as any)[prop])) {
                var cfRecords = getAllRecordsFromField((fieldsBase as any)[prop]);

                records = records.concat(cfRecords);
            }
        }

        return records;
    }

    export function getAllRecordsFromField(field: CompositeField): Record[] {
        var records = [];
        var fieldObj: any = field;

        for (var fProp in field) {
            if (fProp == "errors" || fProp == "constructor" || fProp.indexOf("_") != 0) {
                continue;
            }

            if (isRecord(fieldObj[fProp])) {
                records.push(fieldObj[fProp])
            }

            if (ObjectHelper.isArray(fieldObj[fProp])) {
                for (var elem of fieldObj[fProp]) {
                    if (isRecord(elem)) {
                        records.push(elem)
                    }
                }
            }
        }

        return records;
    }

    export function updateRecordOperation(record: Record) {
        if (record.recordOperation != RecordOperations.Erase) {

            if (isRecordDirty(record)) {
                record.recordOperation = RecordOperations.Add;
            }
            else {
                record.recordOperation = RecordOperations.Current;
            }
        }
    }

    export function getIdentType(ident: string): IndentTypes {
        if (ident) {
            if (ident.length == 6 && ValidatorHelpers.validateBirthDate(ident, false)) {
                return IndentTypes.BirthDate;
            } else if (ident.length == 9 && ValidatorHelpers.isValidUIC(ident)) {
                return IndentTypes.UIC;
            } else if (ident.length == 10 && ValidatorHelpers.isValidEGN(ident)) {
                return IndentTypes.EGN;
            } else if (ident.length == 10 && ValidatorHelpers.isValidLNCH(ident)) {
                return IndentTypes.LNCH;
            } else {
                return IndentTypes.Undefined;
            }
        }

        return IndentTypes.Undefined;
    }

    export function isValidIdentType(indentMode: IndentValidationMode, idType: IndentTypes): boolean {

        let isValid = true;

        switch (indentMode) {
            case IndentValidationMode.All:
                if (idType != IndentTypes.EGN && idType != IndentTypes.LNCH && idType != IndentTypes.BirthDate && idType != IndentTypes.UIC
                    && idType != IndentTypes.Bulstat)
                    isValid = false;
                break;
            case IndentValidationMode.EgnLnchBd:
                if (idType != IndentTypes.EGN && idType != IndentTypes.LNCH && idType != IndentTypes.BirthDate)
                    isValid = false;
                break;
            case IndentValidationMode.EgnLnch:
                if (idType != IndentTypes.EGN && idType != IndentTypes.LNCH)
                    isValid = false;
                break;
            case IndentValidationMode.UIC:
                if (idType != IndentTypes.UIC)
                    isValid = false;
                break;
            case IndentValidationMode.EGN:
                if (idType != IndentTypes.EGN)
                    isValid = false;
        }

        return isValid;
    }

    export function isObjectEmpty(obj: BaseDataModel, propsDefaultValues: Dictionary<string, any> = undefined, propChain: string = undefined): boolean {
        if (!obj) {
            return true;
        }

        let ignoreProps: string[];

        if (isRecord(obj)) {
            ignoreProps = recordSystemProps;
        }
        else {
            /*полето с грешките не очаства в провеката дали обекта е празен*/
            ignoreProps = ["errors"];
        }

        let typeInfo = TypeSystem.getTypeInfo(obj)

        for (var propInfo of typeInfo.properties) {
            if (ignoreProps.indexOf(propInfo.name) >= 0) {
                continue;
            }

            let fullPropName = propChain ? propChain + '.' + propInfo.name : propInfo.name;
            let propValue = (<any>obj)[propInfo.name];
            let propDefaultValue = propsDefaultValues ? propsDefaultValues.getValue(fullPropName) : undefined;

            //Да се помисли дали ако propValue е null, a propDefaultValue не е да се връща false
            if (!propValue || (propDefaultValue && propDefaultValue == propValue)) {
                continue;
            }
            else if (typeInfo.name == "Address" && propInfo.name == "isForeign") {
                continue;
            }
            else if (propInfo.type.isClass && propInfo.type.name != "moment" && propInfo.type.name != "duration") {
                let isObjEmpty = isObjectEmpty(propValue, propsDefaultValues, fullPropName);

                if (isObjEmpty) {
                    continue;
                }
            }
            else if (propInfo.type.isArray) {
                var propValuesArray: any[] = propValue;

                if (propValuesArray.length == 0) {
                    continue;
                }

                var elementType = propInfo.type.getElementType();

                for (var propElemValue of propValuesArray) {
                    if (!propElemValue || (propDefaultValue && propDefaultValue == propElemValue)) {
                        continue;
                    }
                    else if (elementType.isClass && elementType.name != "moment" && elementType.name != "duration") {
                        let isObjEmpty = isObjectEmpty(propElemValue, propsDefaultValues, fullPropName);

                        if (isObjEmpty) {
                            continue;
                        }
                    }

                    return false;
                }
            }

            return false;
        }

        return true;
    }

    //#region Helpers

    function compareWithModelInitState(model: BaseDataModel, modelIniState: any): boolean {
        var hasDifference = false;
        var modelState: any = model;

        if (!modelIniState && model)
            return true;

        if (!model && modelIniState)
            return true;

        for (var prop in modelIniState) {
            if (recordSystemProps.indexOf(prop) >= 0 && isRecord(model)) {
                continue;
            }

            //TODO: Тази полета от обектите OutgoingNumber и Address не се сравняват за в бъдеще трябва да ги разкараме от моделите
            if (['fullOutgoingNumber'].indexOf(prop) >= 0) {
                continue;
            }


            if (ObjectHelper.isSubClassOf(modelState[prop], BaseDataModel)) {
                hasDifference = compareWithModelInitState(modelState[prop], modelIniState[prop]);

                if (hasDifference) {
                    break;
                }
            }
            else if (ObjectHelper.isArray(modelState[prop])) {
                if ((!modelState[prop] || modelState[prop].length == 0) &&
                    (!modelIniState[prop] || modelIniState[prop].length == 0)) {
                    continue;
                }

                if (modelState[prop].length != modelIniState[prop].length) {
                    hasDifference = true;
                    break;
                }

                for (var i = 0; i < modelState[prop].length; i++) {
                    if (ObjectHelper.isSubClassOf(modelState[prop][i], BaseDataModel)) {
                        hasDifference = compareWithModelInitState(modelState[prop][i], modelIniState[prop][i]);
                        if (hasDifference) {
                            break;
                        }
                    }
                    else {
                        if (!modelState[prop][i] && !modelIniState[prop][i]) {
                            continue;
                        }

                        if (modelState[prop][i] != modelIniState[prop][i]) {
                            hasDifference = true;
                            break;
                        }
                    }
                }

                if (hasDifference) {
                    break;
                }
            }
            else {

                if (!modelState[prop] && !modelIniState[prop]) {
                    continue;
                }

                if (isMoment(modelState[prop])) {
                    if (!modelIniState[prop] || modelState[prop].diff(modelIniState[prop]) != 0) {
                        hasDifference = true;
                        break;
                    }
                }
                else if (modelState[prop] != modelIniState[prop]) {
                    hasDifference = true;
                    break;
                }
            }
        }

        return hasDifference;
    }
    //#endregion
}