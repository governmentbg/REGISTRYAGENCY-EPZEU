import { BaseDataModel, ObjectHelper, ArrayHelper } from 'Cnsys.Core';
import { BG_COUNTRY_ID } from 'EPZEU.Core';
import { Dictionary } from 'typescript-collections';
import { Address, ApplicationFormFieldsBase, IndentTypes } from '..';
import { DomainModelHepler } from '../../DomainModelHepler';
import { bgCountry } from '../../ModuleBootstrapper';
import { moduleContext } from '../../ModuleContext';
import { Record, RecordOperations, ProcessStates } from '../ModelsAutoGenerated';
import { IApplicationFormValidationContext } from './ApplicationFormValidationContext';

export namespace ValidatorHelpers {

    export function hasMandatoryRecordsForChange(processState: ProcessStates, records: Record[], checkForErasedRecords: boolean = false): boolean {

        if (processState != ProcessStates.ForChange)
            return true;

        if (checkForErasedRecords) {
            let countOfErasedRecods: number = ArrayHelper.queryable.from(records).where(m => m.recordOperation == RecordOperations.Erase).count();

            if (countOfErasedRecods > 0)
                return true;
        }

        for (var i = 0; i < records.length; i++) {

            if (records[i].recordOperation == RecordOperations.Current || records[i].recordOperation == RecordOperations.Erase) {

            } else {

                return true;
            }
        }

        return false;
    }

    export function canBeMarkedForErase(record: Record, valCtx: IApplicationFormValidationContext) {

        //ако полето е маркирано за изтриване но изтриването му не в позволено
        if (record.recordOperation == RecordOperations.Erase && !(!valCtx.isRecordNew(record) && !valCtx.isRecordEmpty(record) && !valCtx.isRecordDirty(record))) {
            
            return false;
        }

        return true;
    }

    export function validateBirthDate(inputeBirthDate: string, inEGN: boolean): boolean {
        if (inputeBirthDate.length != 6) return false;

        let digits: number[] = [];

        for (let i: number = 0; i < inputeBirthDate.length; i++) {

            let currDigit: number = +inputeBirthDate[i];

            if (!isNaN(currDigit))
                digits.push(currDigit);
            else
                return false;
        }

        let dd: number = digits[4] * 10 + digits[5];
        let mm: number = digits[2] * 10 + digits[3];
        let yy: number = digits[0] * 10 + digits[1];

        if (inEGN) {
            if (mm > 40) {
                if (!checkdate(dd, mm - 40, yy + 2000)) return false;
            } else {
                if (mm > 20) {
                    if (!checkdate(dd, mm - 20, yy + 1800)) return false;
                } else {
                    if (!checkdate(dd, mm, yy + 1900)) return false;
                }
            }

            return true;
        }

        return checkdate(dd, mm, yy)
    }

    export function isLeapYear(yyyy: number): boolean {
        if (yyyy % 400 == 0) { return true; }
        if (yyyy % 100 == 0) { return false; }
        if (yyyy % 4 == 0) { return true; }
        return false;
    }

    export function isValidLNCH(ident: string): boolean {
        let coeffs: number[] = [21, 19, 17, 13, 11, 9, 7, 3, 1];
        let checksum: number = 0;

        for (let i: number = 0; i < coeffs.length; i++) {
            let currDigit: number = Number(ident[i]);
            if (isNaN(currDigit))
                return false;

            checksum += currDigit * coeffs[i];
        }

        checksum %= 10;
        if (checksum == 10) checksum = 0;

        return isNaN(Number(ident[9])) || checksum != Number(ident[9]) ? false : true;
    }

    export function isValidEGN(ident: string): boolean {

        if (ident == null || ident == undefined || ident.length != 10)
            return false;

        if (!validateBirthDate(ident.substr(0, 6), true))
            return false;

        let coeffs: number[] = [2, 4, 8, 5, 10, 9, 7, 3, 6];

        let checksum: number = 0;

        for (let i: number = 0; i < coeffs.length; i++) {
            let currDigit: number = Number(ident[i]);
            if (isNaN(currDigit))
                return false;

            checksum += currDigit * coeffs[i];
        }

        checksum %= 11;
        if (checksum == 10) checksum = 0;

        return isNaN(Number(ident[9])) || checksum != Number(ident[9]) ? false : true;
    }

    export function isValidUIC(ident: string): boolean {
        if (ObjectHelper.isStringNullOrEmpty(ident))
            return false;

        if (!(/^\d{9}$/.test(ident) || /^\d{13}$/.test(ident)))
            return false;

        let checksum: number = 0;

        for (let i: number = 0; i < (ident.length - 1); i++) {
            let currDigit: number = Number(ident[i]);
            if (isNaN(currDigit))
                return false;

            checksum += currDigit * (i + 1);
        }

        checksum %= 11;
        if (checksum == 10) {
            checksum = 0;

            for (let i: number = 0; i < (ident.length - 1); i++) {
                let currDigit: number = Number(ident[i]);

                checksum += currDigit * (i + 3);
            }

            checksum %= 11;
            if (checksum == 10) checksum = 0;
        }

        return isNaN(Number(ident[8])) || checksum != Number(ident[8]) ? false : true;
    }

    export function isValidDate(date: any): boolean {
        if (date == null || date == undefined || (typeof date == "string"))
            return false;

        return date.isValid();
    }

    //Валидация за попълване на име на физическо лице
    export function isValidPersonName(name: string): boolean {
        //Текстовото поле не трябва да съдържа символи различни от:
        //букви на кирилица
        //букви на латиница
        //други символи - празна позиция, тире и апостроф  

        if (ObjectHelper.isStringNullOrEmpty(name))
            return true;

        let pattern = new RegExp("^[А-Яа-яA-Za-z-' ]+$")
        let result = pattern.test(name);

        return result;
    }

    //Валидация за попълнено поле Физическо или Юридическо лице - основни данни - име, идентификатор, държава, чуждестранно юридическо лице
    export function isEmptyBasePerson(name: string, indent: string, countryID: number, isForeignTrader: boolean): boolean {
        //Валидацията връща да, когато нищо от полето не е попълнено или е попълнено само държава България

        if (!ObjectHelper.isStringNullOrEmpty(name)
            || !ObjectHelper.isStringNullOrEmpty(indent)
            || (ObjectHelper.isNullOrUndefined(isForeignTrader) && isForeignTrader)
            || (!ObjectHelper.isNullOrUndefined(countryID) && countryID != BG_COUNTRY_ID))
            return false;

        return true;
    }

    export function areAllFieldsEmpty(...emptyFieldCandidates: any[]) {

        for (var i = 0; i < emptyFieldCandidates.length; i++) {

            if (!ObjectHelper.isStringNullOrEmpty(emptyFieldCandidates[i]) && emptyFieldCandidates[i] !== false)
                return false;
        }

        return true;
    }

    //Валидация за попълнено име или идентификатор на поле Физическо или Юридическо лице 
    export function isNameOrIndentRequired(name: string, indent: string, isForeignTrader: boolean): boolean {
        //Валидацията връща да, когато едно от полетата име или идентификатор липсва
        //При избрано чуждестранно юридическо лице, полето идентификатор може и да не е попълнено

        if (ObjectHelper.isNullOrUndefined(isForeignTrader))
            isForeignTrader = false;

        if ((!ObjectHelper.isStringNullOrEmpty(name) && ObjectHelper.isStringNullOrEmpty(indent) && !isForeignTrader)
            || (ObjectHelper.isStringNullOrEmpty(name) && !ObjectHelper.isStringNullOrEmpty(indent))
            || (ObjectHelper.isStringNullOrEmpty(name) && ObjectHelper.isStringNullOrEmpty(indent) && isForeignTrader))
            return true;

        return false;
    }

    //Валидация за попълненa държава България
    export function isCountryBGRequired(countryID: number, indentType: IndentTypes, isForeignTrader: boolean, onlyEGN: boolean): boolean {
        //Валидацията връща да, когато едно от полетата име или идентификатор липсва
        //При избрано чуждестранно юридическо лице, полето идентификатор може и да не е попълнено
        if (ObjectHelper.isNullOrUndefined(isForeignTrader))
            isForeignTrader = false;

        if (isForeignTrader)
            return false;

        if (onlyEGN) {
            if (!ObjectHelper.isNullOrUndefined(countryID) && countryID != BG_COUNTRY_ID && indentType == IndentTypes.EGN)
                return true;
        }
        else if (!ObjectHelper.isNullOrUndefined(countryID) && countryID != BG_COUNTRY_ID &&
            (indentType == IndentTypes.EGN || indentType == IndentTypes.UIC || indentType == IndentTypes.Bulstat))
            return true;

        return false;
    }

    //Валидация за поле адрес
    export function isEmptyAddress(address: Address): boolean {

        if (!ObjectHelper.isNullOrUndefined(address.countryID) ||
            !ObjectHelper.isNullOrUndefined(address.settlementID) ||
            !ObjectHelper.isStringNullOrEmpty(address.foreignPlace) ||
            !ObjectHelper.isNullOrUndefined(address.areaID) ||
            !ObjectHelper.isStringNullOrEmpty(address.postCode) ||
            !ObjectHelper.isStringNullOrEmpty(address.street) ||
            !ObjectHelper.isStringNullOrEmpty(address.housingEstate) ||
            !ObjectHelper.isStringNullOrEmpty(address.block) ||
            !ObjectHelper.isStringNullOrEmpty(address.entrance) ||
            !ObjectHelper.isStringNullOrEmpty(address.floor) ||
            !ObjectHelper.isStringNullOrEmpty(address.streetNumber) ||
            !ObjectHelper.isStringNullOrEmpty(address.apartment))
            return false;

        return true;
    }

    //Валидация за дублиране на идентификатори в списък с персони
    export function isExistDublicateIndents(objList: Record[], isPerson: boolean, errorKey: string): boolean {

        //Ако и двата рекърда са със статус current и с еднакив идентификатори не показваме грешка
        let isExist = false;
        let arrEGNs: { egn: string, recordOperation: RecordOperations }[] = [];
        let personType: string = "person";

        if (!isPerson)
            personType = "subject";

        for (var i = 0; i < objList.length; i++) {

            if (objList[i].recordOperation == RecordOperations.Erase)
                continue;

            let person = (<any>objList[i])[personType];
            let currEGN: string = person.indent;
            let idType = DomainModelHepler.getIdentType(currEGN);

            if ((isPerson && (idType == IndentTypes.EGN || idType == IndentTypes.LNCH)) ||
                (!isPerson && (idType == IndentTypes.EGN || idType == IndentTypes.LNCH) || idType == IndentTypes.UIC || idType == IndentTypes.Bulstat)) {

                if (currEGN) {
                    if (arrEGNs.filter(x => x.egn == currEGN && (x.recordOperation != RecordOperations.Current || objList[i].recordOperation != RecordOperations.Current)).length > 0) {
                        person.addError(moduleContext.resourceManager.getResourceByKey(errorKey));
                        isExist = true;
                    }

                    arrEGNs.push({ egn: currEGN, recordOperation: objList[i].recordOperation });
                }
            }
        }

        return isExist;
    }

    export function isObjectWithPersonEmpty(obj: BaseDataModel, personPropName: string): boolean {
        let propsDefaultValues = new Dictionary<string, any>();

        propsDefaultValues.setValue(personPropName + ".countryCode", bgCountry.code)
        propsDefaultValues.setValue(personPropName + ".countryID", bgCountry.id)
        propsDefaultValues.setValue(personPropName + ".countryName", bgCountry.name)

        return DomainModelHepler.isObjectEmpty(obj, propsDefaultValues);
    }

    export function isObjectWithAddressEmpty(obj: BaseDataModel, addressPropName: string): boolean {
        let propsDefaultValues = new Dictionary<string, any>();

        propsDefaultValues.setValue(addressPropName + ".countryCode", bgCountry.code)
        propsDefaultValues.setValue(addressPropName + ".countryID", bgCountry.id)
        propsDefaultValues.setValue(addressPropName + ".country", bgCountry.name)

        return DomainModelHepler.isObjectEmpty(obj, propsDefaultValues);
    }

    export function hasNewRecords(model: ApplicationFormFieldsBase, excludedFromCheck?: Record): boolean {
        let records = DomainModelHepler.getAllRecordsFromFieldsBase(model);
        let excludedRecordIndex = records.indexOf(excludedFromCheck);
        if (excludedRecordIndex > -1) { records.splice(excludedRecordIndex, 1) } else { null };

        for (var i = 0; i < records.length; i++) {
            if (records[i].recordOperation != RecordOperations.Current) {
                return true;
            }
        }

        return false;
    }

    export function isValidEmailAddress(email: string): boolean {
        if (email == null || email == undefined)
            return false;

        let isValid = /^[_A-Za-z0-9-\+]+(\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\.[A-Za-z0-9]+)*(\.[A-Za-z]{2,})$/.test(email)

        return isValid;
    }

    //#region Private helpers

    function checkdate(d: number, m: number, y: number) {

        return m > 0 && m < 13 && y >= 0 && y < 32768 && d > 0 && (d <= (new Date(y, m, 0)).getDate() || (y == 0 && m == 2 && d == 29))
    }

    //#endregion
}