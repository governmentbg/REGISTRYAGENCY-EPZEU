//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace EPZEU.Signing.BtrustRemoteClient
{
    using System = global::System;
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial interface IBtrustRemoteClient
    {
        /// <summary>Relying Party to Client Authorization</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="authInfo">Параметри за оторизиране</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClientAuthResponse> ClientAuthUsingPOSTAsync(string accept_language, AuthInfo authInfo, string relyingPartyID);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Relying Party to Client Authorization</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="authInfo">Параметри за оторизиране</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClientAuthResponse> ClientAuthUsingPOSTAsync(string accept_language, AuthInfo authInfo, string relyingPartyID, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get client certificate</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="personalId">EGN или LNC</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClientCertResponse> GetCertByPersonalIdUsingGETAsync(string accept_language, string personalId, string relyingPartyID);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get client certificate</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="personalId">EGN или LNC</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClientCertResponse> GetCertByPersonalIdUsingGETAsync(string accept_language, string personalId, string relyingPartyID, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get client certificate</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="profileId">ID на облачния КЕП</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClientCertResponse> GetCertUsingGETAsync(string accept_language, string profileId, string relyingPartyID);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get client certificate</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="profileId">ID на облачния КЕП</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClientCertResponse> GetCertUsingGETAsync(string accept_language, string profileId, string relyingPartyID, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Consume documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="documentRequest">Документи за броене</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката за консумиране на документите е успешна</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GeneralResponse> ConsumeDocumentsUsingPOSTAsync(string accept_language, OTCPACSignRequest documentRequest, string relyingPartyID);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Consume documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="documentRequest">Документи за броене</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката за консумиране на документите е успешна</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GeneralResponse> ConsumeDocumentsUsingPOSTAsync(string accept_language, OTCPACSignRequest documentRequest, string relyingPartyID, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Archive otc documents sign by client</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="archiveRequest">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendSignResponse> ArchiveOtcDocumentsUsingPOSTAsync(string accept_language, OTCArchiveRequest archiveRequest, string relyingPartyID, string rpToClientAuthorization);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Archive otc documents sign by client</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="archiveRequest">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendSignResponse> ArchiveOtcDocumentsUsingPOSTAsync(string accept_language, OTCArchiveRequest archiveRequest, string relyingPartyID, string rpToClientAuthorization, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Подписан файл as Base64</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GeneralResponse> GetOTCSignedContentUsingGETAsync(string accept_language, int id, string relyingPartyID);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Подписан файл as Base64</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GeneralResponse> GetOTCSignedContentUsingGETAsync(string accept_language, int id, string relyingPartyID, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Send Sign Request</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendSignResponse> SignOtcDocumentsUsingPOSTAsync(string accept_language, OTCSignRequest body, string relyingPartyID, string rpToClientAuthorization);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send Sign Request</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendSignResponse> SignOtcDocumentsUsingPOSTAsync(string accept_language, OTCSignRequest body, string relyingPartyID, string rpToClientAuthorization, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get list of all requested sign documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="requestedId">Филтър - requestedId</param>
        /// <param name="userId">Филтър - User_ID</param>
        /// <returns>Заявката детайлна информация за подписванията успешно обработена</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignHistoryResponse> GetRequestDocumentsHistoryDetailsUsingGETAsync(string accept_language, string relyingPartyID, long requestedId, long userId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get list of all requested sign documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="requestedId">Филтър - requestedId</param>
        /// <param name="userId">Филтър - User_ID</param>
        /// <returns>Заявката детайлна информация за подписванията успешно обработена</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignHistoryResponse> GetRequestDocumentsHistoryDetailsUsingGETAsync(string accept_language, string relyingPartyID, long requestedId, long userId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get list of all requested sign documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="fromCreatedDate">Филтър - от ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="limit">Елементи на страница</param>
        /// <param name="offset">страница</param>
        /// <param name="order">Вид на подреждане. По подразбиране е DESC.</param>
        /// <param name="orderByFilter">Филтър за подреждане по параметър. По подразбиране е createdDate.</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="status">Филтър - cтатус на подписа</param>
        /// <param name="textToShow">Филтър -  Документ</param>
        /// <param name="toCreatedDate">Филтър - до ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="userId">Филтър - User_ID</param>
        /// <returns>Заявката за подписване е изпратена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignHistoryResponse> GetRequestDocumentsHistoryUsingGETAsync(string accept_language, System.DateTimeOffset? fromCreatedDate, int? limit, int? offset, Order? order, OrderByFilter? orderByFilter, string relyingPartyID, Status? status, string textToShow, System.DateTimeOffset? toCreatedDate, long userId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get list of all requested sign documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="fromCreatedDate">Филтър - от ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="limit">Елементи на страница</param>
        /// <param name="offset">страница</param>
        /// <param name="order">Вид на подреждане. По подразбиране е DESC.</param>
        /// <param name="orderByFilter">Филтър за подреждане по параметър. По подразбиране е createdDate.</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="status">Филтър - cтатус на подписа</param>
        /// <param name="textToShow">Филтър -  Документ</param>
        /// <param name="toCreatedDate">Филтър - до ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="userId">Филтър - User_ID</param>
        /// <returns>Заявката за подписване е изпратена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignHistoryResponse> GetRequestDocumentsHistoryUsingGETAsync(string accept_language, System.DateTimeOffset? fromCreatedDate, int? limit, int? offset, Order? order, OrderByFilter? orderByFilter, string relyingPartyID, Status? status, string textToShow, System.DateTimeOffset? toCreatedDate, long userId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get signed content by relying party callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpCallbackId">ID на заявката за подписване, изпратено от доверяващата страна</param>
        /// <returns>Всички файлове са подписани</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignedContentsResponse> GetSignedResultByRpCallbackIdUsingGETAsync(string accept_language, string relyingPartyID, string rpCallbackId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by relying party callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpCallbackId">ID на заявката за подписване, изпратено от доверяващата страна</param>
        /// <returns>Всички файлове са подписани</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignedContentsResponse> GetSignedResultByRpCallbackIdUsingGETAsync(string accept_language, string relyingPartyID, string rpCallbackId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Send Sign Request</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendSignResponse> SendSignRequestUsingPOSTAsync(string accept_language, SignRequest body, string relyingPartyID, string rpToClientAuthorization);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send Sign Request</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendSignResponse> SendSignRequestUsingPOSTAsync(string accept_language, SignRequest body, string relyingPartyID, string rpToClientAuthorization, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Подписан файл</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetSignedContentUsingGETAsync(string accept_language, int id, string relyingPartyID);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Подписан файл</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetSignedContentUsingGETAsync(string accept_language, int id, string relyingPartyID, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="userId">${api.param.userId.value}</param>
        /// <returns>Подписан файл</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetSignedContentUserIdUsingGETAsync(string accept_language, int id, string relyingPartyID, int userId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="userId">${api.param.userId.value}</param>
        /// <returns>Подписан файл</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetSignedContentUserIdUsingGETAsync(string accept_language, int id, string relyingPartyID, int userId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get list of signed content</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificateNumber">Филтър - сериен номер на сертификат</param>
        /// <param name="fromCreatedDate">Филтър - от ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="isLogin">Филтър - дали подписа е за вход в системата</param>
        /// <param name="limit">Елементи на страница</param>
        /// <param name="offset">страница</param>
        /// <param name="order">Вид на подреждане. По подразбиране е DESC.</param>
        /// <param name="orderByFilter">Филтър за подреждане по параметър. По подразбиране е createdDate.</param>
        /// <param name="relayingParty">Филтър - доверяващата се страна</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="signatureType">Филтър - формата на подписа</param>
        /// <param name="status">Филтър - cтатус на подписа</param>
        /// <param name="textToShow">Филтър -  Документ</param>
        /// <param name="toCreatedDate">Филтър - до ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <returns>Заявката за подписване е изпратена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignHistoryResponse> GetSignHistoryUsingGETAsync(string accept_language, System.Collections.Generic.IEnumerable<string> certificateNumber, System.DateTimeOffset? fromCreatedDate, bool? isLogin, int? limit, int? offset, Order2? order, OrderByFilter2? orderByFilter, string relayingParty, string relyingPartyID, SignatureType? signatureType, Status2? status, string textToShow, System.DateTimeOffset? toCreatedDate);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get list of signed content</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificateNumber">Филтър - сериен номер на сертификат</param>
        /// <param name="fromCreatedDate">Филтър - от ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="isLogin">Филтър - дали подписа е за вход в системата</param>
        /// <param name="limit">Елементи на страница</param>
        /// <param name="offset">страница</param>
        /// <param name="order">Вид на подреждане. По подразбиране е DESC.</param>
        /// <param name="orderByFilter">Филтър за подреждане по параметър. По подразбиране е createdDate.</param>
        /// <param name="relayingParty">Филтър - доверяващата се страна</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="signatureType">Филтър - формата на подписа</param>
        /// <param name="status">Филтър - cтатус на подписа</param>
        /// <param name="textToShow">Филтър -  Документ</param>
        /// <param name="toCreatedDate">Филтър - до ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <returns>Заявката за подписване е изпратена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignHistoryResponse> GetSignHistoryUsingGETAsync(string accept_language, System.Collections.Generic.IEnumerable<string> certificateNumber, System.DateTimeOffset? fromCreatedDate, bool? isLogin, int? limit, int? offset, Order2? order, OrderByFilter2? orderByFilter, string relayingParty, string relyingPartyID, SignatureType? signatureType, Status2? status, string textToShow, System.DateTimeOffset? toCreatedDate, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get report of archived signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="reportType">Тип на доказателството (simple/detailed)</param>
        /// <returns>Доказателство</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetSignedContentReportUsingGETAsync(string accept_language, int id, string relyingPartyID, ReportType reportType);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get report of archived signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="reportType">Тип на доказателството (simple/detailed)</param>
        /// <returns>Доказателство</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetSignedContentReportUsingGETAsync(string accept_language, int id, string relyingPartyID, ReportType reportType, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="callbackId">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Всички файлове са подписани</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignedContentsResponse> GetSignedResultUsingGETAsync(string accept_language, string callbackId, string relyingPartyID);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="callbackId">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Всички файлове са подписани</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SignedContentsResponse> GetSignedResultUsingGETAsync(string accept_language, string callbackId, string relyingPartyID, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Send Sign Request via QR</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на съдържание, чрез сканиране на QR код</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendSignResponseViaQr> SendSignRequestViaQRUsingPOSTAsync(string accept_language, SignRequestViaQr body, string relyingPartyID);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send Sign Request via QR</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на съдържание, чрез сканиране на QR код</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendSignResponseViaQr> SendSignRequestViaQRUsingPOSTAsync(string accept_language, SignRequestViaQr body, string relyingPartyID, System.Threading.CancellationToken cancellationToken);
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    internal partial class BtrustRemoteClient : IBtrustRemoteClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public BtrustRemoteClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Relying Party to Client Authorization</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="authInfo">Параметри за оторизиране</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ClientAuthResponse> ClientAuthUsingPOSTAsync(string accept_language, AuthInfo authInfo, string relyingPartyID)
        {
            return ClientAuthUsingPOSTAsync(accept_language, authInfo, relyingPartyID, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Relying Party to Client Authorization</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="authInfo">Параметри за оторизиране</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ClientAuthResponse> ClientAuthUsingPOSTAsync(string accept_language, AuthInfo authInfo, string relyingPartyID, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/auth");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(authInfo, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClientAuthResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ClientAuthResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get client certificate</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="personalId">EGN или LNC</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ClientCertResponse> GetCertByPersonalIdUsingGETAsync(string accept_language, string personalId, string relyingPartyID)
        {
            return GetCertByPersonalIdUsingGETAsync(accept_language, personalId, relyingPartyID, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get client certificate</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="personalId">EGN или LNC</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ClientCertResponse> GetCertByPersonalIdUsingGETAsync(string accept_language, string personalId, string relyingPartyID, System.Threading.CancellationToken cancellationToken)
        {
            if (personalId == null)
                throw new System.ArgumentNullException("personalId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/cert/identity/{personalId}");
            urlBuilder_.Replace("{personalId}", System.Uri.EscapeDataString(ConvertToString(personalId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClientCertResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0421\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u044a\u0442 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ClientCertResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get client certificate</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="profileId">ID на облачния КЕП</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ClientCertResponse> GetCertUsingGETAsync(string accept_language, string profileId, string relyingPartyID)
        {
            return GetCertUsingGETAsync(accept_language, profileId, relyingPartyID, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get client certificate</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="profileId">ID на облачния КЕП</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката е изпълнена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ClientCertResponse> GetCertUsingGETAsync(string accept_language, string profileId, string relyingPartyID, System.Threading.CancellationToken cancellationToken)
        {
            if (profileId == null)
                throw new System.ArgumentNullException("profileId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/cert/{profileId}");
            urlBuilder_.Replace("{profileId}", System.Uri.EscapeDataString(ConvertToString(profileId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClientCertResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0421\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u044a\u0442 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ClientCertResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Consume documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="documentRequest">Документи за броене</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката за консумиране на документите е успешна</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GeneralResponse> ConsumeDocumentsUsingPOSTAsync(string accept_language, OTCPACSignRequest documentRequest, string relyingPartyID)
        {
            return ConsumeDocumentsUsingPOSTAsync(accept_language, documentRequest, relyingPartyID, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Consume documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="documentRequest">Документи за броене</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Заявката за консумиране на документите е успешна</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GeneralResponse> ConsumeDocumentsUsingPOSTAsync(string accept_language, OTCPACSignRequest documentRequest, string relyingPartyID, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/otc-pac/consume");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(documentRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GeneralResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0438\u044f \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0438\u043b\u0438 request ID \u043d\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(GeneralResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Archive otc documents sign by client</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="archiveRequest">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SendSignResponse> ArchiveOtcDocumentsUsingPOSTAsync(string accept_language, OTCArchiveRequest archiveRequest, string relyingPartyID, string rpToClientAuthorization)
        {
            return ArchiveOtcDocumentsUsingPOSTAsync(accept_language, archiveRequest, relyingPartyID, rpToClientAuthorization, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Archive otc documents sign by client</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="archiveRequest">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SendSignResponse> ArchiveOtcDocumentsUsingPOSTAsync(string accept_language, OTCArchiveRequest archiveRequest, string relyingPartyID, string rpToClientAuthorization, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/otc/archive");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    if (rpToClientAuthorization == null)
                        throw new System.ArgumentNullException("rpToClientAuthorization");
                    request_.Headers.TryAddWithoutValidation("rpToClientAuthorization", ConvertToString(rpToClientAuthorization, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(archiveRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendSignResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "202") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendSignResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0438\u044f \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0438\u043b\u0438 request ID \u043d\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SendSignResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Подписан файл as Base64</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GeneralResponse> GetOTCSignedContentUsingGETAsync(string accept_language, int id, string relyingPartyID)
        {
            return GetOTCSignedContentUsingGETAsync(accept_language, id, relyingPartyID, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Подписан файл as Base64</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GeneralResponse> GetOTCSignedContentUsingGETAsync(string accept_language, int id, string relyingPartyID, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/otc/content/{id}");
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=UTF-8"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GeneralResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041f\u043e\u0434\u043f\u0438\u0441\u0430\u043d\u043e\u0442\u043e \u0441\u044a\u0434\u044a\u0440\u0436\u0430\u043d\u0438\u0435 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(GeneralResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Send Sign Request</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SendSignResponse> SignOtcDocumentsUsingPOSTAsync(string accept_language, OTCSignRequest body, string relyingPartyID, string rpToClientAuthorization)
        {
            return SignOtcDocumentsUsingPOSTAsync(accept_language, body, relyingPartyID, rpToClientAuthorization, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send Sign Request</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SendSignResponse> SignOtcDocumentsUsingPOSTAsync(string accept_language, OTCSignRequest body, string relyingPartyID, string rpToClientAuthorization, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/otc/sign");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    if (rpToClientAuthorization == null)
                        throw new System.ArgumentNullException("rpToClientAuthorization");
                    request_.Headers.TryAddWithoutValidation("rpToClientAuthorization", ConvertToString(rpToClientAuthorization, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendSignResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "202") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendSignResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0438\u044f \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0438\u043b\u0438 request ID \u043d\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SendSignResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get list of all requested sign documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="requestedId">Филтър - requestedId</param>
        /// <param name="userId">Филтър - User_ID</param>
        /// <returns>Заявката детайлна информация за подписванията успешно обработена</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SignHistoryResponse> GetRequestDocumentsHistoryDetailsUsingGETAsync(string accept_language, string relyingPartyID, long requestedId, long userId)
        {
            return GetRequestDocumentsHistoryDetailsUsingGETAsync(accept_language, relyingPartyID, requestedId, userId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get list of all requested sign documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="requestedId">Филтър - requestedId</param>
        /// <param name="userId">Филтър - User_ID</param>
        /// <returns>Заявката детайлна информация за подписванията успешно обработена</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SignHistoryResponse> GetRequestDocumentsHistoryDetailsUsingGETAsync(string accept_language, string relyingPartyID, long requestedId, long userId, System.Threading.CancellationToken cancellationToken)
        {
            if (requestedId == null)
                throw new System.ArgumentNullException("requestedId");
    
            if (userId == null)
                throw new System.ArgumentNullException("userId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/requested-sign-documents/details?");
            urlBuilder_.Append(System.Uri.EscapeDataString("requestedId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(requestedId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append(System.Uri.EscapeDataString("userId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SignHistoryResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SignHistoryResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get list of all requested sign documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="fromCreatedDate">Филтър - от ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="limit">Елементи на страница</param>
        /// <param name="offset">страница</param>
        /// <param name="order">Вид на подреждане. По подразбиране е DESC.</param>
        /// <param name="orderByFilter">Филтър за подреждане по параметър. По подразбиране е createdDate.</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="status">Филтър - cтатус на подписа</param>
        /// <param name="textToShow">Филтър -  Документ</param>
        /// <param name="toCreatedDate">Филтър - до ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="userId">Филтър - User_ID</param>
        /// <returns>Заявката за подписване е изпратена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SignHistoryResponse> GetRequestDocumentsHistoryUsingGETAsync(string accept_language, System.DateTimeOffset? fromCreatedDate, int? limit, int? offset, Order? order, OrderByFilter? orderByFilter, string relyingPartyID, Status? status, string textToShow, System.DateTimeOffset? toCreatedDate, long userId)
        {
            return GetRequestDocumentsHistoryUsingGETAsync(accept_language, fromCreatedDate, limit, offset, order, orderByFilter, relyingPartyID, status, textToShow, toCreatedDate, userId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get list of all requested sign documents</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="fromCreatedDate">Филтър - от ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="limit">Елементи на страница</param>
        /// <param name="offset">страница</param>
        /// <param name="order">Вид на подреждане. По подразбиране е DESC.</param>
        /// <param name="orderByFilter">Филтър за подреждане по параметър. По подразбиране е createdDate.</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="status">Филтър - cтатус на подписа</param>
        /// <param name="textToShow">Филтър -  Документ</param>
        /// <param name="toCreatedDate">Филтър - до ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="userId">Филтър - User_ID</param>
        /// <returns>Заявката за подписване е изпратена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SignHistoryResponse> GetRequestDocumentsHistoryUsingGETAsync(string accept_language, System.DateTimeOffset? fromCreatedDate, int? limit, int? offset, Order? order, OrderByFilter? orderByFilter, string relyingPartyID, Status? status, string textToShow, System.DateTimeOffset? toCreatedDate, long userId, System.Threading.CancellationToken cancellationToken)
        {
            if (userId == null)
                throw new System.ArgumentNullException("userId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/requested-sign-documents/list?");
            if (fromCreatedDate != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fromCreatedDate") + "=").Append(System.Uri.EscapeDataString(fromCreatedDate.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (limit != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (offset != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("offset") + "=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (order != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("order") + "=").Append(System.Uri.EscapeDataString(ConvertToString(order, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderByFilter != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("orderByFilter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(orderByFilter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (status != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("status") + "=").Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (textToShow != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("textToShow") + "=").Append(System.Uri.EscapeDataString(ConvertToString(textToShow, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (toCreatedDate != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("toCreatedDate") + "=").Append(System.Uri.EscapeDataString(toCreatedDate.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Append(System.Uri.EscapeDataString("userId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SignHistoryResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SignHistoryResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get signed content by relying party callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpCallbackId">ID на заявката за подписване, изпратено от доверяващата страна</param>
        /// <returns>Всички файлове са подписани</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SignedContentsResponse> GetSignedResultByRpCallbackIdUsingGETAsync(string accept_language, string relyingPartyID, string rpCallbackId)
        {
            return GetSignedResultByRpCallbackIdUsingGETAsync(accept_language, relyingPartyID, rpCallbackId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by relying party callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpCallbackId">ID на заявката за подписване, изпратено от доверяващата страна</param>
        /// <returns>Всички файлове са подписани</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SignedContentsResponse> GetSignedResultByRpCallbackIdUsingGETAsync(string accept_language, string relyingPartyID, string rpCallbackId, System.Threading.CancellationToken cancellationToken)
        {
            if (rpCallbackId == null)
                throw new System.ArgumentNullException("rpCallbackId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/rpcallbackid/{rpCallbackId}");
            urlBuilder_.Replace("{rpCallbackId}", System.Uri.EscapeDataString(ConvertToString(rpCallbackId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SignedContentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "206") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SignedContentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041f\u043e\u0434\u043f\u0438\u0441\u0430\u043d\u043e\u0442\u043e \u0441\u044a\u0434\u044a\u0440\u0436\u0430\u043d\u0438\u0435 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SignedContentsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Send Sign Request</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SendSignResponse> SendSignRequestUsingPOSTAsync(string accept_language, SignRequest body, string relyingPartyID, string rpToClientAuthorization)
        {
            return SendSignRequestUsingPOSTAsync(accept_language, body, relyingPartyID, rpToClientAuthorization, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send Sign Request</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на документ</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="rpToClientAuthorization">Механизмът на оторизиране на доверяващата страна, което да й позволи да изпраща документи за подписване към съответния потребител</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SendSignResponse> SendSignRequestUsingPOSTAsync(string accept_language, SignRequest body, string relyingPartyID, string rpToClientAuthorization, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/sign");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    if (rpToClientAuthorization == null)
                        throw new System.ArgumentNullException("rpToClientAuthorization");
                    request_.Headers.TryAddWithoutValidation("rpToClientAuthorization", ConvertToString(rpToClientAuthorization, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendSignResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "202") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendSignResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0438\u044f \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0438\u043b\u0438 request ID \u043d\u0430 \u0441\u0435\u0440\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u0430 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SendSignResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Подписан файл</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetSignedContentUsingGETAsync(string accept_language, int id, string relyingPartyID)
        {
            return GetSignedContentUsingGETAsync(accept_language, id, relyingPartyID, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Подписан файл</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetSignedContentUsingGETAsync(string accept_language, int id, string relyingPartyID, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/sign/content/{id}");
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041f\u043e\u0434\u043f\u0438\u0441\u0430\u043d\u043e\u0442\u043e \u0441\u044a\u0434\u044a\u0440\u0436\u0430\u043d\u0438\u0435 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="userId">${api.param.userId.value}</param>
        /// <returns>Подписан файл</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetSignedContentUserIdUsingGETAsync(string accept_language, int id, string relyingPartyID, int userId)
        {
            return GetSignedContentUserIdUsingGETAsync(accept_language, id, relyingPartyID, userId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="userId">${api.param.userId.value}</param>
        /// <returns>Подписан файл</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetSignedContentUserIdUsingGETAsync(string accept_language, int id, string relyingPartyID, int userId, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");
    
            if (userId == null)
                throw new System.ArgumentNullException("userId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/sign/content/{id}/userId/{userId}");
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{userId}", System.Uri.EscapeDataString(ConvertToString(userId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041f\u043e\u0434\u043f\u0438\u0441\u0430\u043d\u043e\u0442\u043e \u0441\u044a\u0434\u044a\u0440\u0436\u0430\u043d\u0438\u0435 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get list of signed content</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificateNumber">Филтър - сериен номер на сертификат</param>
        /// <param name="fromCreatedDate">Филтър - от ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="isLogin">Филтър - дали подписа е за вход в системата</param>
        /// <param name="limit">Елементи на страница</param>
        /// <param name="offset">страница</param>
        /// <param name="order">Вид на подреждане. По подразбиране е DESC.</param>
        /// <param name="orderByFilter">Филтър за подреждане по параметър. По подразбиране е createdDate.</param>
        /// <param name="relayingParty">Филтър - доверяващата се страна</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="signatureType">Филтър - формата на подписа</param>
        /// <param name="status">Филтър - cтатус на подписа</param>
        /// <param name="textToShow">Филтър -  Документ</param>
        /// <param name="toCreatedDate">Филтър - до ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <returns>Заявката за подписване е изпратена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SignHistoryResponse> GetSignHistoryUsingGETAsync(string accept_language, System.Collections.Generic.IEnumerable<string> certificateNumber, System.DateTimeOffset? fromCreatedDate, bool? isLogin, int? limit, int? offset, Order2? order, OrderByFilter2? orderByFilter, string relayingParty, string relyingPartyID, SignatureType? signatureType, Status2? status, string textToShow, System.DateTimeOffset? toCreatedDate)
        {
            return GetSignHistoryUsingGETAsync(accept_language, certificateNumber, fromCreatedDate, isLogin, limit, offset, order, orderByFilter, relayingParty, relyingPartyID, signatureType, status, textToShow, toCreatedDate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get list of signed content</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="certificateNumber">Филтър - сериен номер на сертификат</param>
        /// <param name="fromCreatedDate">Филтър - от ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <param name="isLogin">Филтър - дали подписа е за вход в системата</param>
        /// <param name="limit">Елементи на страница</param>
        /// <param name="offset">страница</param>
        /// <param name="order">Вид на подреждане. По подразбиране е DESC.</param>
        /// <param name="orderByFilter">Филтър за подреждане по параметър. По подразбиране е createdDate.</param>
        /// <param name="relayingParty">Филтър - доверяващата се страна</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="signatureType">Филтър - формата на подписа</param>
        /// <param name="status">Филтър - cтатус на подписа</param>
        /// <param name="textToShow">Филтър -  Документ</param>
        /// <param name="toCreatedDate">Филтър - до ВРЕМЕ НА СЪЗДАВАНЕ НА ЗАПИСА</param>
        /// <returns>Заявката за подписване е изпратена успешно</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SignHistoryResponse> GetSignHistoryUsingGETAsync(string accept_language, System.Collections.Generic.IEnumerable<string> certificateNumber, System.DateTimeOffset? fromCreatedDate, bool? isLogin, int? limit, int? offset, Order2? order, OrderByFilter2? orderByFilter, string relayingParty, string relyingPartyID, SignatureType? signatureType, Status2? status, string textToShow, System.DateTimeOffset? toCreatedDate, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/sign/list?");
            if (certificateNumber != null) 
            {
                foreach (var item_ in certificateNumber) { urlBuilder_.Append(System.Uri.EscapeDataString("certificateNumber") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fromCreatedDate != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fromCreatedDate") + "=").Append(System.Uri.EscapeDataString(fromCreatedDate.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isLogin != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isLogin") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isLogin, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (limit != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (offset != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("offset") + "=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (order != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("order") + "=").Append(System.Uri.EscapeDataString(ConvertToString(order, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderByFilter != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("orderByFilter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(orderByFilter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (relayingParty != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("relayingParty") + "=").Append(System.Uri.EscapeDataString(ConvertToString(relayingParty, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (signatureType != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("signatureType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(signatureType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (status != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("status") + "=").Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (textToShow != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("textToShow") + "=").Append(System.Uri.EscapeDataString(ConvertToString(textToShow, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (toCreatedDate != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("toCreatedDate") + "=").Append(System.Uri.EscapeDataString(toCreatedDate.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SignHistoryResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SignHistoryResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get report of archived signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="reportType">Тип на доказателството (simple/detailed)</param>
        /// <returns>Доказателство</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetSignedContentReportUsingGETAsync(string accept_language, int id, string relyingPartyID, ReportType reportType)
        {
            return GetSignedContentReportUsingGETAsync(accept_language, id, relyingPartyID, reportType, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get report of archived signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="id">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <param name="reportType">Тип на доказателството (simple/detailed)</param>
        /// <returns>Доказателство</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetSignedContentReportUsingGETAsync(string accept_language, int id, string relyingPartyID, ReportType reportType, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");
    
            if (reportType == null)
                throw new System.ArgumentNullException("reportType");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/sign/report/{id}/{reportType}");
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{reportType}", System.Uri.EscapeDataString(ConvertToString(reportType, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041f\u043e\u0434\u043f\u0438\u0441\u0430\u043d\u043e\u0442\u043e \u0441\u044a\u0434\u044a\u0440\u0436\u0430\u043d\u0438\u0435 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="callbackId">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Всички файлове са подписани</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SignedContentsResponse> GetSignedResultUsingGETAsync(string accept_language, string callbackId, string relyingPartyID)
        {
            return GetSignedResultUsingGETAsync(accept_language, callbackId, relyingPartyID, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get signed content by callback ID</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="callbackId">ID на заявката за подписване, получено като резултат от синхронната операция по заявка за подписване</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>Всички файлове са подписани</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SignedContentsResponse> GetSignedResultUsingGETAsync(string accept_language, string callbackId, string relyingPartyID, System.Threading.CancellationToken cancellationToken)
        {
            if (callbackId == null)
                throw new System.ArgumentNullException("callbackId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/sign/{callbackId}");
            urlBuilder_.Replace("{callbackId}", System.Uri.EscapeDataString(ConvertToString(callbackId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SignedContentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "206") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SignedContentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041f\u043e\u0434\u043f\u0438\u0441\u0430\u043d\u043e\u0442\u043e \u0441\u044a\u0434\u044a\u0440\u0436\u0430\u043d\u0438\u0435 \u043d\u0435 \u0435 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u043e", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SignedContentsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Send Sign Request via QR</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на съдържание, чрез сканиране на QR код</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SendSignResponseViaQr> SendSignRequestViaQRUsingPOSTAsync(string accept_language, SignRequestViaQr body, string relyingPartyID)
        {
            return SendSignRequestViaQRUsingPOSTAsync(accept_language, body, relyingPartyID, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Send Sign Request via QR</summary>
        /// <param name="accept_language">Езикът, на който да бъдат върнати езиково-зависимите съобщения</param>
        /// <param name="body">Параметри за подписване на съдържание, чрез сканиране на QR код</param>
        /// <param name="relyingPartyID">ID на доверяващата се страна</param>
        /// <returns>OK</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SendSignResponseViaQr> SendSignRequestViaQRUsingPOSTAsync(string accept_language, SignRequestViaQr body, string relyingPartyID, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append("v2/signviaqr");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (accept_language != null)
                        request_.Headers.TryAddWithoutValidation("Accept-language", ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture));
                    if (relyingPartyID == null)
                        throw new System.ArgumentNullException("relyingPartyID");
                    request_.Headers.TryAddWithoutValidation("relyingPartyID", ConvertToString(relyingPartyID, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendSignResponseViaQr>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "202") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendSignResponseViaQr>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0432\u0430\u043b\u0438\u0434\u043d\u0438 \u0432\u0445\u043e\u0434\u043d\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0438", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u041d\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043e\u0441\u0442\u044a\u043f", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new SwaggerException("\u0412\u044a\u0442\u0440\u0435\u0448\u043d\u0430 \u0433\u0440\u0435\u0448\u043a\u0430", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SendSignResponseViaQr);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new SwaggerException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new SwaggerException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    /// <summary>Параметри за оторизиране</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AuthInfo 
    {
        /// <summary>ID на потребителя. Видим от клиента през мобилното приложение</summary>
        [Newtonsoft.Json.JsonProperty("profileId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProfileId { get; set; }
    
        /// <summary>Код за еднократната парола. Видим от клиента през мобилното приложение</summary>
        [Newtonsoft.Json.JsonProperty("otp", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Otp { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static AuthInfo FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<AuthInfo>(data);
        }
    
    }
    
    /// <summary>Стандартен отговор за CQES API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ClientAuthResponse 
    {
        /// <summary>Статус на отговора</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Съобщение на отговора. Съобщението може да бъде локализирано в зависимост от 'Accept-language' хедъра</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClientAuthResponseData Data { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ClientAuthResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ClientAuthResponse>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ClientAuthResponseData 
    {
        /// <summary>Клиентски токен, чрез който доверяващата страна може да изпраща заявки за подписване до конкретен потребител по профил ID.</summary>
        [Newtonsoft.Json.JsonProperty("clientToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientToken { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ClientAuthResponseData FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ClientAuthResponseData>(data);
        }
    
    }
    
    /// <summary>Стандартен отговор за CQES API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ClientCertResponse 
    {
        /// <summary>Статус на отговора</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Съобщение на отговора. Съобщението може да бъде локализирано в зависимост от 'Accept-language' хедъра</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClientCertResponseData Data { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ClientCertResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ClientCertResponse>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ClientCertResponseData 
    {
        /// <summary>Kлиентският X509 сертификат в base64 формат</summary>
        [Newtonsoft.Json.JsonProperty("encodedCert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EncodedCert { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ClientCertResponseData FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ClientCertResponseData>(data);
        }
    
    }
    
    /// <summary>Съдържание, което ще бъде подписано от потребителя</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Content 
    {
        /// <summary>Управлява дали да се извежда диалоговия прозорец за потвърждаване на подписване на съдържанието и какъв текст да визуализара в него</summary>
        [Newtonsoft.Json.JsonProperty("confirmText", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ConfirmText { get; set; }
    
        /// <summary>Типа на съдържанието, което ще бъде подписано</summary>
        [Newtonsoft.Json.JsonProperty("contentFormat", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContentFormat ContentFormat { get; set; }
    
        /// <summary>Съдържанието, което ще бъде подписано. Ако типа на документа е BINARY_BASE64 или DIGEST, съдържанието трябва да е BASE64 кодирано. </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Data { get; set; }
    
        /// <summary>Име на документа, който бива подписван. </summary>
        [Newtonsoft.Json.JsonProperty("fileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileName { get; set; }
    
        /// <summary>Подписа ще бъде ли видим в подписани PDF файлове</summary>
        [Newtonsoft.Json.JsonProperty("padesVisualSignature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PadesVisualSignature { get; set; }
    
        /// <summary>Позиция на подписа</summary>
        [Newtonsoft.Json.JsonProperty("signaturePosition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SignaturePositionDTO SignaturePosition { get; set; }
    
        /// <summary>Дали съдържанието да бъде съхранено в дългосрочния архив</summary>
        [Newtonsoft.Json.JsonProperty("toBeArchived", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ToBeArchived { get; set; }
    
        /// <summary>Алгоритъма на подписване на документа</summary>
        [Newtonsoft.Json.JsonProperty("hashAlgorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContentHashAlgorithm? HashAlgorithm { get; set; }
    
        /// <summary>Типа на подписа</summary>
        [Newtonsoft.Json.JsonProperty("signatureType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContentSignatureType? SignatureType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Content FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Content>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data 
    {
        /// <summary>ID на заявка за подписване. ID-то се използва за вземане на резултата от подписването чрез операция getSignedContent.</summary>
        [Newtonsoft.Json.JsonProperty("callbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackId { get; set; }
    
        /// <summary>Крайна дата и време на валидност на заявката. </summary>
        [Newtonsoft.Json.JsonProperty("validity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Validity { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data>(data);
        }
    
    }
    
    /// <summary>Стандартен отговор за CQES API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GeneralResponse 
    {
        /// <summary>Статус на отговора</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Съобщение на отговора. Съобщението може да бъде локализирано в зависимост от 'Accept-language' хедъра</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static GeneralResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<GeneralResponse>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OTCArchiveContent 
    {
        [Newtonsoft.Json.JsonProperty("certReqId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CertReqId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("digestTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DigestTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("digestValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DigestValue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("payer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OTCArchiveContentPayer? Payer { get; set; }
    
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature { get; set; }
    
        [Newtonsoft.Json.JsonProperty("signedDocument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SignedDocument { get; set; }
    
        [Newtonsoft.Json.JsonProperty("unsignedDocument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Content UnsignedDocument { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OTCArchiveContent FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OTCArchiveContent>(data);
        }
    
    }
    
    /// <summary>Request for archiving otc sign documents</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OTCArchiveRequest 
    {
        [Newtonsoft.Json.JsonProperty("contentForArchive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OTCArchiveContent> ContentForArchive { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OTCArchiveRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OTCArchiveRequest>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OTCPACSignRequest 
    {
        [Newtonsoft.Json.JsonProperty("documents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Documents { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OTCPACSignRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OTCPACSignRequest>(data);
        }
    
    }
    
    /// <summary>Заявка за подписване на съдържание</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OTCSignRequest 
    {
        [Newtonsoft.Json.JsonProperty("agentName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AgentName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("agentNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AgentNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("agentPosition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AgentPosition { get; set; }
    
        [Newtonsoft.Json.JsonProperty("contentForArchive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OTCArchiveContent ContentForArchive { get; set; }
    
        [Newtonsoft.Json.JsonProperty("incomingCity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IncomingCity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("incomingDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IncomingDate { get; set; }
    
        [Newtonsoft.Json.JsonProperty("incomingNumberNull", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncomingNumberNull { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mediatorName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MediatorName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mediatorNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MediatorNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mediatorPosition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MediatorPosition { get; set; }
    
        /// <summary>Списък със съдържания за подписване (документ, дайджест или текст)</summary>
        [Newtonsoft.Json.JsonProperty("signRequest", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SignRequest SignRequest { get; set; } = new SignRequest();
    
        /// <summary>incoming number with prefix 1eXXX or 2eXXX or 3eXXX</summary>
        [Newtonsoft.Json.JsonProperty("incomingNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string IncomingNumber { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OTCSignRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OTCSignRequest>(data);
        }
    
    }
    
    /// <summary>Наредена заявка за подписване - списък с подписващи</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RequestedSequence 
    {
        /// <summary>Cert req id на кой трябва да подпише</summary>
        [Newtonsoft.Json.JsonProperty("certReqId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CertReqId { get; set; }
    
        /// <summary>Пореден номер на потребителя който трябва да подпише</summary>
        [Newtonsoft.Json.JsonProperty("sequenceIndex", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SequenceIndex { get; set; }
    
        /// <summary>Време в минути, за което трябва да бъде подписано</summary>
        [Newtonsoft.Json.JsonProperty("timeToSign", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TimeToSign { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static RequestedSequence FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RequestedSequence>(data);
        }
    
    }
    
    /// <summary>Стандартен отговор за CQES API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SendSignResponse 
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Data Data { get; set; }
    
        /// <summary>Статус на отговора</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Съобщение на отговора. Съобщението може да бъде локализирано в зависимост от 'Accept-language' хедъра</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SendSignResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SendSignResponse>(data);
        }
    
    }
    
    /// <summary>Стандартен отговор за CQES API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SendSignResponseViaQr 
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SendSignResponseViaQrData Data { get; set; }
    
        /// <summary>Статус на отговора</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Съобщение на отговора. Съобщението може да бъде локализирано в зависимост от 'Accept-language' хедъра</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SendSignResponseViaQr FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SendSignResponseViaQr>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SendSignResponseViaQrData 
    {
        /// <summary>ID на заявкаа за подписване. ID-то се използва за вземане на резултата от подписването чрез операция getSignedContent.</summary>
        [Newtonsoft.Json.JsonProperty("callbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackId { get; set; }
    
        /// <summary>QR снимка кодирана в Base64 format с размери спрямо подадените в заявката</summary>
        [Newtonsoft.Json.JsonProperty("qrImage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string QrImage { get; set; }
    
        /// <summary>QR линк</summary>
        [Newtonsoft.Json.JsonProperty("qrPlain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string QrPlain { get; set; }
    
        /// <summary>Дата и време на валидност на заявката</summary>
        [Newtonsoft.Json.JsonProperty("validity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Validity { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SendSignResponseViaQrData FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SendSignResponseViaQrData>(data);
        }
    
    }
    
    /// <summary>Стандартен отговор за CQES API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignHistoryResponse 
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SignHistoryResponseData Data { get; set; }
    
        /// <summary>Статус на отговора</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Съобщение на отговора. Съобщението може да бъде локализирано в зависимост от 'Accept-language' хедъра</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignHistoryResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignHistoryResponse>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignHistoryResponseData 
    {
        /// <summary>списък на подписано съдържание</summary>
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SignedContent> Content { get; set; }
    
        /// <summary>брой върнати записи с подписано съдържание</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Size { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignHistoryResponseData FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignHistoryResponseData>(data);
        }
    
    }
    
    /// <summary>Заявка за подписване на съдържание</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignRequest 
    {
        /// <summary>Списък със съдържания за подписване (документ, дайджест или текст)</summary>
        [Newtonsoft.Json.JsonProperty("contents", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Content> Contents { get; set; } = new System.Collections.ObjectModel.Collection<Content>();
    
        /// <summary>ID на заявктата от системата на доверяващата страна. </summary>
        [Newtonsoft.Json.JsonProperty("relyingPartyCallbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RelyingPartyCallbackId { get; set; }
    
        /// <summary>За сметка на кого, ще бъде таксувана операцията по подписването</summary>
        [Newtonsoft.Json.JsonProperty("payer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SignRequestPayer? Payer { get; set; }
    
        /// <summary>Дали заявката се използва за вход в системата</summary>
        [Newtonsoft.Json.JsonProperty("isLogin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsLogin { get; set; }
    
        /// <summary>USER ID на наредител</summary>
        [Newtonsoft.Json.JsonProperty("requestedUserId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RequestedUserId { get; set; }
    
        /// <summary>Списък на подписвачите</summary>
        [Newtonsoft.Json.JsonProperty("requestedSequences", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RequestedSequence> RequestedSequences { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignRequest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignRequest>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignRequestViaQr 
    {
        /// <summary>Височина на картинката на QR кодът, който ще бъде върнат</summary>
        [Newtonsoft.Json.JsonProperty("qrHeight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? QrHeight { get; set; }
    
        /// <summary>Дължина на картинката на QR кодът, който ще бъде върнат</summary>
        [Newtonsoft.Json.JsonProperty("qrWidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? QrWidth { get; set; }
    
        /// <summary>Параметри за подписване на съдържание</summary>
        [Newtonsoft.Json.JsonProperty("request", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SignRequestWithSingleContent Request { get; set; } = new SignRequestWithSingleContent();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignRequestViaQr FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignRequestViaQr>(data);
        }
    
    }
    
    /// <summary>Заявка за подписване на съдържание</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignRequestWithSingleContent 
    {
        /// <summary>Съдържание за подписване (файл, дайджест или текст)</summary>
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Content Content { get; set; } = new Content();
    
        /// <summary>ID на заявктата от системата на доверяващата страна. </summary>
        [Newtonsoft.Json.JsonProperty("relyingPartyCallbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RelyingPartyCallbackId { get; set; }
    
        /// <summary>За сметка на кого, ще бъде таксувана операцията по подписването</summary>
        [Newtonsoft.Json.JsonProperty("payer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SignRequestWithSingleContentPayer? Payer { get; set; }
    
        /// <summary>Дали заявката се използва за вход в системата</summary>
        [Newtonsoft.Json.JsonProperty("isLogin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsLogin { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignRequestWithSingleContent FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignRequestWithSingleContent>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignaturePositionDTO 
    {
        [Newtonsoft.Json.JsonProperty("imageHeight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ImageHeight { get; set; }
    
        [Newtonsoft.Json.JsonProperty("imageWidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ImageWidth { get; set; }
    
        [Newtonsoft.Json.JsonProperty("imageXAxis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ImageXAxis { get; set; }
    
        [Newtonsoft.Json.JsonProperty("imageYAxis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ImageYAxis { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pageNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PageNumber { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignaturePositionDTO FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignaturePositionDTO>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignatureResponse 
    {
        /// <summary>Съдържа подписа или референция към подписания документ. 
        /// - При тип на подписа SINGATURЕ се връща чистия подпис кодиран в BASE64. 
        /// - При останалите типове подписи се връща ID на документа, който може да бъде изтеглен чрез операцията getSignedContent</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature { get; set; }
    
        /// <summary>Типа на подписа, който ще бъде върнат като резултат.</summary>
        [Newtonsoft.Json.JsonProperty("signatureType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SignatureResponseSignatureType? SignatureType { get; set; }
    
        /// <summary>Статуса на подписа, който ще бъде върнат като резултат.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SignatureResponseStatus? Status { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignatureResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignatureResponse>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignedContent 
    {
        [Newtonsoft.Json.JsonProperty("archiveStatusId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ArchiveStatusId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("callbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CallbackId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("certId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? CertId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("certSerialNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CertSerialNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("contentTypeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ContentTypeId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("createdDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Timestamp CreatedDate { get; set; }
    
        [Newtonsoft.Json.JsonProperty("displayedText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayedText { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fileId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FileId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("receivedDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Timestamp ReceivedDate { get; set; }
    
        [Newtonsoft.Json.JsonProperty("relyingPartyId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RelyingPartyId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("relyingPartyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RelyingPartyName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rpCallbackId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RpCallbackId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("signType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SignedContentSignType? SignType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("signedDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Timestamp SignedDate { get; set; }
    
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SignedContentStatus? Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("toBeArchived", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ToBeArchived { get; set; }
    
        [Newtonsoft.Json.JsonProperty("usageIdDownloadRequested", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? UsageIdDownloadRequested { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignedContent FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignedContent>(data);
        }
    
    }
    
    /// <summary>Стандартен отговор за CQES API</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignedContentsResponse 
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SignedContentsResponseData Data { get; set; }
    
        /// <summary>Статус на отговора</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Съобщение на отговора. Съобщението може да бъде локализирано в зависимост от 'Accept-language' хедъра</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignedContentsResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignedContentsResponse>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignedContentsResponseData 
    {
        /// <summary>Публичния ключ на сертификата, чрез който са подписани файловете в BASE64 Формат. Подава се само при тип на подписа SIGNATURE</summary>
        [Newtonsoft.Json.JsonProperty("cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cert { get; set; }
    
        /// <summary>Списък с подписи и съответните статуси. Подредбата на списъка следва тази на подадените документи.</summary>
        [Newtonsoft.Json.JsonProperty("signatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SignatureResponse> Signatures { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static SignedContentsResponseData FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<SignedContentsResponseData>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Timestamp 
    {
        [Newtonsoft.Json.JsonProperty("date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Date { get; set; }
    
        [Newtonsoft.Json.JsonProperty("day", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Day { get; set; }
    
        [Newtonsoft.Json.JsonProperty("hours", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Hours { get; set; }
    
        [Newtonsoft.Json.JsonProperty("minutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Minutes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("month", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Month { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nanos", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Nanos { get; set; }
    
        [Newtonsoft.Json.JsonProperty("seconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Seconds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Time { get; set; }
    
        [Newtonsoft.Json.JsonProperty("timezoneOffset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TimezoneOffset { get; set; }
    
        [Newtonsoft.Json.JsonProperty("year", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Year { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Timestamp FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Timestamp>(data);
        }
    
    }
    
    /// <summary>Вид на подреждане. По подразбиране е DESC.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Order
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ASC")]
        ASC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DESC")]
        DESC = 1,
    
    }
    
    /// <summary>Филтър за подреждане по параметър. По подразбиране е createdDate.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OrderByFilter
    {
        [System.Runtime.Serialization.EnumMember(Value = @"createdDate")]
        CreatedDate = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"displayedText")]
        DisplayedText = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"downloadeTimestamp")]
        DownloadeTimestamp = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"relyingPartyId")]
        RelyingPartyId = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"relyingPartyName")]
        RelyingPartyName = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"status")]
        Status = 5,
    
    }
    
    /// <summary>Филтър - cтатус на подписа</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNED")]
        SIGNED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RECEIVED")]
        RECEIVED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECTED")]
        REJECTED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARCHIVED")]
        ARCHIVED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REMOVED")]
        REMOVED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPIRED")]
        EXPIRED = 7,
    
    }
    
    /// <summary>Вид на подреждане. По подразбиране е DESC.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Order2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ASC")]
        ASC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DESC")]
        DESC = 1,
    
    }
    
    /// <summary>Филтър за подреждане по параметър. По подразбиране е createdDate.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OrderByFilter2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"createdDate")]
        CreatedDate = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"signedDate")]
        SignedDate = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"displayedText")]
        DisplayedText = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"certId")]
        CertId = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"certSerialNumber")]
        CertSerialNumber = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"relyingPartyId")]
        RelyingPartyId = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"relyingPartyName")]
        RelyingPartyName = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"status")]
        Status = 7,
    
    }
    
    /// <summary>Филтър - формата на подписа</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SignatureType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATURE")]
        SIGNATURE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_B_ATACHED")]
        CADES_BASELINE_B_ATACHED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_T_ATACHED")]
        CADES_BASELINE_T_ATACHED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LT_ATACHED")]
        CADES_BASELINE_LT_ATACHED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_ATACHED")]
        CADES_BASELINE_LTA_ATACHED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_ENVELOPED")]
        CADES_BASELINE_LTA_ENVELOPED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_B_DETACHED")]
        CADES_BASELINE_B_DETACHED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_T_DETACHED")]
        CADES_BASELINE_T_DETACHED = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LT_DETACHED")]
        CADES_BASELINE_LT_DETACHED = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_DETACHED")]
        CADES_BASELINE_LTA_DETACHED = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_B")]
        PADES_BASELINE_B = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_T")]
        PADES_BASELINE_T = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_LT")]
        PADES_BASELINE_LT = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_LTA")]
        PADES_BASELINE_LTA = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_ENVELOPED")]
        XADES_BASELINE_B_ENVELOPED = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_ENVELOPED")]
        XADES_BASELINE_T_ENVELOPED = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_ENVELOPED")]
        XADES_BASELINE_LT_ENVELOPED = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_ENVELOPED")]
        XADES_BASELINE_LTA_ENVELOPED = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_ENVELOPING")]
        XADES_BASELINE_B_ENVELOPING = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_ENVELOPING")]
        XADES_BASELINE_T_ENVELOPING = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_ENVELOPING")]
        XADES_BASELINE_LT_ENVELOPING = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_ENVELOPING")]
        XADES_BASELINE_LTA_ENVELOPING = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_DETACHED")]
        XADES_BASELINE_B_DETACHED = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_DETACHED")]
        XADES_BASELINE_T_DETACHED = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_DETACHED")]
        XADES_BASELINE_LT_DETACHED = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_DETACHED")]
        XADES_BASELINE_LTA_DETACHED = 25,
    
    }
    
    /// <summary>Филтър - cтатус на подписа</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Status2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNED")]
        SIGNED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RECEIVED")]
        RECEIVED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECTED")]
        REJECTED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARCHIVED")]
        ARCHIVED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REMOVED")]
        REMOVED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPIRED")]
        EXPIRED = 7,
    
    }
    
    /// <summary>Тип на доказателството (simple/detailed)</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ReportType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SIMPLE")]
        SIMPLE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DETAILED")]
        DETAILED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContentFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DIGEST")]
        DIGEST = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BINARY_BASE64")]
        BINARY_BASE64 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEXT")]
        TEXT = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContentHashAlgorithm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SHA256")]
        SHA256 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA512")]
        SHA512 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ContentSignatureType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATURE")]
        SIGNATURE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_B_ATACHED")]
        CADES_BASELINE_B_ATACHED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_T_ATACHED")]
        CADES_BASELINE_T_ATACHED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LT_ATACHED")]
        CADES_BASELINE_LT_ATACHED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_ATACHED")]
        CADES_BASELINE_LTA_ATACHED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_ENVELOPED")]
        CADES_BASELINE_LTA_ENVELOPED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_B_DETACHED")]
        CADES_BASELINE_B_DETACHED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_T_DETACHED")]
        CADES_BASELINE_T_DETACHED = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LT_DETACHED")]
        CADES_BASELINE_LT_DETACHED = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_DETACHED")]
        CADES_BASELINE_LTA_DETACHED = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_B")]
        PADES_BASELINE_B = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_T")]
        PADES_BASELINE_T = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_LT")]
        PADES_BASELINE_LT = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_LTA")]
        PADES_BASELINE_LTA = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_ENVELOPED")]
        XADES_BASELINE_B_ENVELOPED = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_ENVELOPED")]
        XADES_BASELINE_T_ENVELOPED = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_ENVELOPED")]
        XADES_BASELINE_LT_ENVELOPED = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_ENVELOPED")]
        XADES_BASELINE_LTA_ENVELOPED = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_ENVELOPING")]
        XADES_BASELINE_B_ENVELOPING = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_ENVELOPING")]
        XADES_BASELINE_T_ENVELOPING = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_ENVELOPING")]
        XADES_BASELINE_LT_ENVELOPING = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_ENVELOPING")]
        XADES_BASELINE_LTA_ENVELOPING = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_DETACHED")]
        XADES_BASELINE_B_DETACHED = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_DETACHED")]
        XADES_BASELINE_T_DETACHED = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_DETACHED")]
        XADES_BASELINE_LT_DETACHED = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_DETACHED")]
        XADES_BASELINE_LTA_DETACHED = 25,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OTCArchiveContentPayer
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RELYING_PARTY")]
        RELYING_PARTY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLIENT")]
        CLIENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SignRequestPayer
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RELYING_PARTY")]
        RELYING_PARTY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLIENT")]
        CLIENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SignRequestWithSingleContentPayer
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RELYING_PARTY")]
        RELYING_PARTY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLIENT")]
        CLIENT = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SignatureResponseSignatureType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATURE")]
        SIGNATURE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_B_ATACHED")]
        CADES_BASELINE_B_ATACHED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_T_ATACHED")]
        CADES_BASELINE_T_ATACHED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LT_ATACHED")]
        CADES_BASELINE_LT_ATACHED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_ATACHED")]
        CADES_BASELINE_LTA_ATACHED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_ENVELOPED")]
        CADES_BASELINE_LTA_ENVELOPED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_B_DETACHED")]
        CADES_BASELINE_B_DETACHED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_T_DETACHED")]
        CADES_BASELINE_T_DETACHED = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LT_DETACHED")]
        CADES_BASELINE_LT_DETACHED = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_DETACHED")]
        CADES_BASELINE_LTA_DETACHED = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_B")]
        PADES_BASELINE_B = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_T")]
        PADES_BASELINE_T = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_LT")]
        PADES_BASELINE_LT = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_LTA")]
        PADES_BASELINE_LTA = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_ENVELOPED")]
        XADES_BASELINE_B_ENVELOPED = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_ENVELOPED")]
        XADES_BASELINE_T_ENVELOPED = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_ENVELOPED")]
        XADES_BASELINE_LT_ENVELOPED = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_ENVELOPED")]
        XADES_BASELINE_LTA_ENVELOPED = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_ENVELOPING")]
        XADES_BASELINE_B_ENVELOPING = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_ENVELOPING")]
        XADES_BASELINE_T_ENVELOPING = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_ENVELOPING")]
        XADES_BASELINE_LT_ENVELOPING = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_ENVELOPING")]
        XADES_BASELINE_LTA_ENVELOPING = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_DETACHED")]
        XADES_BASELINE_B_DETACHED = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_DETACHED")]
        XADES_BASELINE_T_DETACHED = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_DETACHED")]
        XADES_BASELINE_LT_DETACHED = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_DETACHED")]
        XADES_BASELINE_LTA_DETACHED = 25,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SignatureResponseStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNED")]
        SIGNED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RECEIVED")]
        RECEIVED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECTED")]
        REJECTED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARCHIVED")]
        ARCHIVED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REMOVED")]
        REMOVED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPIRED")]
        EXPIRED = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SignedContentSignType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNATURE")]
        SIGNATURE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_B_ATACHED")]
        CADES_BASELINE_B_ATACHED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_T_ATACHED")]
        CADES_BASELINE_T_ATACHED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LT_ATACHED")]
        CADES_BASELINE_LT_ATACHED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_ATACHED")]
        CADES_BASELINE_LTA_ATACHED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_ENVELOPED")]
        CADES_BASELINE_LTA_ENVELOPED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_B_DETACHED")]
        CADES_BASELINE_B_DETACHED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_T_DETACHED")]
        CADES_BASELINE_T_DETACHED = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LT_DETACHED")]
        CADES_BASELINE_LT_DETACHED = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CADES_BASELINE_LTA_DETACHED")]
        CADES_BASELINE_LTA_DETACHED = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_B")]
        PADES_BASELINE_B = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_T")]
        PADES_BASELINE_T = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_LT")]
        PADES_BASELINE_LT = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PADES_BASELINE_LTA")]
        PADES_BASELINE_LTA = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_ENVELOPED")]
        XADES_BASELINE_B_ENVELOPED = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_ENVELOPED")]
        XADES_BASELINE_T_ENVELOPED = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_ENVELOPED")]
        XADES_BASELINE_LT_ENVELOPED = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_ENVELOPED")]
        XADES_BASELINE_LTA_ENVELOPED = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_ENVELOPING")]
        XADES_BASELINE_B_ENVELOPING = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_ENVELOPING")]
        XADES_BASELINE_T_ENVELOPING = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_ENVELOPING")]
        XADES_BASELINE_LT_ENVELOPING = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_ENVELOPING")]
        XADES_BASELINE_LTA_ENVELOPING = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_B_DETACHED")]
        XADES_BASELINE_B_DETACHED = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_T_DETACHED")]
        XADES_BASELINE_T_DETACHED = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LT_DETACHED")]
        XADES_BASELINE_LT_DETACHED = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"XADES_BASELINE_LTA_DETACHED")]
        XADES_BASELINE_LTA_DETACHED = 25,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SignedContentStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ERROR")]
        ERROR = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGNED")]
        SIGNED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RECEIVED")]
        RECEIVED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REJECTED")]
        REJECTED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ARCHIVED")]
        ARCHIVED = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REMOVED")]
        REMOVED = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPIRED")]
        EXPIRED = 7,
    
    }

    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client; 
        private System.IDisposable _response; 

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode; 
            Headers = headers; 
            Stream = stream; 
            _client = client; 
            _response = response;
        }

        public void Dispose() 
        {
            if (Stream != null)
                Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class SwaggerException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class SwaggerException<TResult> : SwaggerException
    {
        public TResult Result { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108